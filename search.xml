<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ownerReferences、Finalizers与garbage collector</title>
    <url>/2022/03/30/finalizers&amp;ownerReferences&amp;garbagecollector/</url>
    <content><![CDATA[<h1 id="ownerReferences"><a href="#ownerReferences" class="headerlink" title="ownerReferences"></a>ownerReferences</h1><p><code>ownerReferences</code>指明了资源的属主，即当前对象依赖于<code>ownerReferences</code>指向的对象。比如创建一个<code>deployment</code>，pod的属主为该pod对应的<code>replicaSet</code>（简称rs），同样这个<code>rs</code>也有一个属主引用，指向一个对应的<code>deployment</code>，以一个<code>nginx-deployment</code>为例，pod和rs的<code>ownerReferences</code>如下：</p>
<p><code>pod</code>的<code>ownerReferences</code>字段</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2022-03-29T08:06:34Z&quot;</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">nginx-deployment-6c575444d8-</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">pod-template-hash:</span> <span class="string">6c575444d8</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment-6c575444d8-5424w</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test-cxz</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment-6c575444d8</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">646cd157-df56-46d5-9432-d0b5f9557f5a</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;40445528&quot;</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">c904db91-5082-4ff8-8a01-a35a5206e5ea</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>rs的<code>ownerReferences</code>字段</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">pod-template-hash:</span> <span class="string">6c575444d8</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment-6c575444d8</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test-cxz</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">02a5d50a-8832-4a3e-9498-eb907b04a7a1</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;40452750&quot;</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">646cd157-df56-46d5-9432-d0b5f9557f5a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到pod和rs各自<code>ownerReferences</code>对应的属主对象，pod的属主对象是rs，rs的属主对象是deployment。<code>ownerReferences</code>包含了属主对象的一些属性，包括apiversion、kind、uid、name等通用属性，<code>controller</code>字段表明属主对象是否是一个控制器，<code>blockOwnerDeletion</code>为true则表明删除属主对象时，会阻塞删除操作，因为有别的对象依赖它，这里删除<code>replicaSet</code>会阻塞，要等到它选中的pod也删除之后这个<code>rs</code>才会最终被删除。具体删除流程下文会具体介绍，这里先理解<code>ownerReferences</code>这一基本概念。</p>
<h1 id="Finalizers"><a href="#Finalizers" class="headerlink" title="Finalizers"></a>Finalizers</h1><p><code>finalizers</code>通常用来阻止资源的删除，其值是一个字符串slice，是依赖和被依赖对象间可以理解的一组key，当一个资源的<code>finalizers</code>字段不为空时，在删除该对象时，只会设置该对象的<code>deletionTimestamp</code>字段，代表正在删除中，只有当条件满足<code>finalizers</code>字段被移除，该对象才可以被最终删除。例如一个pod使用了pv，则该pv会被设置一个key为pv-protection的<code>finalizers</code>，表示不能直接删除这个pv，因为有pod在使用它，只有当pod不再使用该pv，这个<code>finalizers</code>字段才会被移除，此时这个pv才会被最终删除。</p>
<p>以删除<code>configMap</code>为例，首先创建一个包含<code>finalizer</code>的<code>configMap</code>，key为“kubernetes”。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | kubectl create -f -</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: mymap</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>然后使用<code>kubectl</code>删除该<code>configMap</code>，并让其后台运行，如果没有其他任何操作，该命令会在后台一直运行，这是因为<code>kubectl</code>默认会等到<code>configMap</code>这个资源从etcd中删除后才会退出，而由于该<code>configMap</code>带有不为空的<code>finalizer</code>，所以并没有从etcd存储中删除，删除请求到<code>kube-apiserver</code>后，<code>kube-apiserver</code>只是更新了<code>configMap</code>的删除时间戳<code>deletionTimestamp</code>，可以重新get该资源来确认这一点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete configmap/mymap &amp;</span><br><span class="line">configmap &quot;mymap&quot; deleted</span><br><span class="line">jobs</span><br><span class="line">[1]+  Running kubectl delete configmap/mymap</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get configmap/mymap -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2022-03-29T11:24:39Z&quot;</span><br><span class="line">  deletionGracePeriodSeconds: 0</span><br><span class="line">  deletionTimestamp: &quot;2022-03-29T11:24:53Z&quot;</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">  name: mymap</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;40468237&quot;</span><br><span class="line">  uid: 73525bff-6888-466f-b6c3-8c50227175f0</span><br></pre></td></tr></table></figure>

<p>然后我们尝试更新该<code>configMap</code>，删除其<code>finalizer</code>字段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl patch configmap/mymap \</span><br><span class="line">    --type json \</span><br><span class="line">    --patch=&#x27;[ &#123; &quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/metadata/finalizers&quot; &#125; ]&#x27;</span><br><span class="line">configmap/mymap patched</span><br><span class="line">[1]+  Done  kubectl delete configmap/mymap</span><br></pre></td></tr></table></figure>

<p>更新完后，上一步的<code>kubectl</code>删除操作此时才会结束退出，这虽然是一个更新操作，但到达<code>kube-apiserver</code>后，<code>kube-apiserver</code>发现该<code>configMap</code>的<code>deletionTimestamp</code>不为空即已经被标记了删除，同时更新完<code>finalizer</code>字段也变空，所以会直接从<code>etcd</code>中删除该<code>configMap</code>，而<code>kubectl</code>一直在watch等待该资源被删除，等watch到删除事件，<code>kubectl</code>退出，删除操作完成。</p>
<h1 id="级联删除与garbage-collector"><a href="#级联删除与garbage-collector" class="headerlink" title="级联删除与garbage collector"></a>级联删除与garbage collector</h1><h2 id="级联删除cascade"><a href="#级联删除cascade" class="headerlink" title="级联删除cascade"></a>级联删除cascade</h2><p>在<code>kubernetes</code>早期版本（1.3之前），当使用<code>kubectl</code>删除时，级联删除的操作都在客户端完成，比如删除<code>replicaSet</code>，客户端先删除pod，然后再去删除<code>replicaSet</code>，这样导致客户端逻辑复杂，不利于扩展，之后实现了<code>garbage collector</code>垃圾收集器这一控制器，在server端实现级联删除的逻辑。</p>
<p>当使用<code>kubectl delete</code>删除资源时，可以设置<code>--cascade</code>参数指定级联删除策略，共有三种模式</p>
<ul>
<li><code>background</code>：默认策略，后台删除</li>
<li><code>orphan</code>：孤立删除</li>
<li><code>foreground</code>：前台删除</li>
</ul>
<p>这三种策略都需要<code>garbage collector</code>配合完成，以删除<code>deployment</code>为例，三者具体区别在于：</p>
<ul>
<li>使用<code>background</code>删除策略时，删除deployment的请求到达<code>kube-apiserver</code>，<code>deployment</code>先被删除，然后<code>garbage collector</code>删除<code>replicaSet</code>，然删除<code>replicaSet</code>对应的pod；</li>
<li>使用<code>orphan</code>删除策略，请求到达<code>kube-apiserver</code>，<code>deployment</code>被设置<code>deletionTimestamp</code>标记删除，并设置key为orphan的<code>finalizer</code>，garbage collector移除<code>replicaSet</code>的<code>ownerReferences</code>的字段，解除<code>deployment</code>和<code>replicaSet</code>的关系，同时删除<code>deployment</code>的<code>finalizer</code>字段，然后<code>deployment</code>被最终删除，此时<code>replicaSet</code>和pod仍然存在不受影响，因此称为孤立删除，即只删除<code>deployment</code>，不删除对应的<code>replicaSet</code>和pod；</li>
<li>使用<code>foreground</code>删除策略，<code>deployment</code>被设置<code>kube-apiserver</code>设置key为<code>foreground</code>的<code>finalizer</code>，garbage collector发现有<code>replicaSet</code>依赖<code>deployment</code>，同时pod依赖<code>replicaSet</code>，于是将<code>replicaSet</code>同样设置key为foreground的<code>finalizer</code>，然后找到依赖于<code>replicaSet</code>的pod，使用<code>background</code>策略直接删除进而删除<code>replicaSet</code>和<code>deployment</code>，与<code>background</code>的删除策略主要不同在于先删除pod，再删除<code>replicaSet</code>，最后删除deployment，并通过设置 <code>finalizer</code>控制删除顺序。</li>
</ul>
<h2 id="garbage-collector原理"><a href="#garbage-collector原理" class="headerlink" title="garbage collector原理"></a>garbage collector原理</h2><p>级联删除的主要逻辑都由<code>garbage collector</code>这一控制器来控制，<code>garbage collector</code>由两部分组成：<code>graph_builder</code>和<code>garbagecollector</code>。</p>
<p><code>graph_builder</code>用来维护集群中资源的依赖拓扑图，每种资源被视为一个节点，这个节点同时存储了该节点资源对应的<code>owner</code>以及依赖，比例<code>replicaSet</code>存储了其<code>owner</code> <code>deployment</code>，同时存储了其依赖的pod，这样就可以通过每个节点直接找到其属主<code>owner</code>和依赖。<code>graph_builder</code>通过<code>metaInformer</code>监听集群meta数据变化，动态更新资源间的依赖关系。然后将需要删除的资源的放入队列，根据不同的删除策略<code>orphan</code>或者<code>foreground</code>分别放入不同的队列。</p>
<p><code>garbagecollector</code>是上述两个队列的消费者，对于<code>orphan</code>队列里的待删除资源，主要操作为删除依赖对象的<code>ownerReferences</code>，使其孤立，并通过删除<code>owner</code>对象的<code>finalizer</code>使<code>kube-apiserver</code>删除<code>owner</code>对象。对于<code>foreground</code>队列里的待删除资源，则是不断寻找被删除资源的依赖资源，类似于递归操作，当一个最底层的对象不再被其他对象依赖时，通过指定其删除策略为<code>background</code>直接从存储层删除吗，对于<code>owner</code>对象则通过移除其值为<code>foreground</code>的<code>finalizer</code>来删除该对象。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/">https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/</a></li>
<li><a href="https://kubernetes.io/docs/concepts/architecture/garbage-collection/">https://kubernetes.io/docs/concepts/architecture/garbage-collection/</a></li>
<li><a href="https://github.com/kubernetes/design-proposals-archive/blob/main/api-machinery/garbage-collection.md">https://github.com/kubernetes/design-proposals-archive/blob/main/api-machinery/garbage-collection.md</a></li>
</ol>
]]></content>
      <tags>
        <tag>K8s</tag>
        <tag>Pod</tag>
        <tag>垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>Pod删除流程及长期处于Terminating状态分析</title>
    <url>/2022/03/30/pod_terminating/</url>
    <content><![CDATA[<p>使用kubectl删除pod时，通常会看到pod首先处于Terminating状态，正常情况下过段时间pod就会被彻底删除，而在某些异常场景下pod则会一直处于Terminating状态，直到特定条件被满足。这涉及到kubernetes对pod等资源的优雅删除，即不会立即从etcd中删除，而是等待一个<code>gracePeriod</code>让pod中的container在被彻底kill前执行<code>preStop</code>或者业务自定义的处理，避免容器的突然中止导致业务出错。那么kubernetes内部到底是如何处理pod删除事件的，pod结束Terminating状态的特定条件又有哪些？本文将从源码层面予以解释。</p>
<h1 id="kubectl行为"><a href="#kubectl行为" class="headerlink" title="kubectl行为"></a>kubectl行为</h1><p><code>kubectl delete</code>有两个参数<code>--force</code>和<code>--grace-period</code>，默认分别为false和-1，前者为true表示直接从etcd删除不进行优雅删除，后者可以指定优雅删除的宽限期，只有<code>--force</code>为true该值才可以设置为0，表示强制删除而不管pod残留的资源有没有被清理干净。默认使用<code>kubectl</code>如果未显式指定两个参数则忽略<code>grace-period</code>，然后转化为一个DeleteOptions作为参数传递给kube-apiserver，<code>GracePeriodSeconds</code>即为设置的宽限期。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DeleteOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    GracePeriodSeconds *<span class="keyword">int64</span> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="kube-apiserver行为"><a href="#kube-apiserver行为" class="headerlink" title="kube-apiserver行为"></a>kube-apiserver行为</h1><p>kube-apiserver使用go-restful作为server端web框架，因此要想清楚kube-apiserver接收到删除请求的具体处理流程，就应该找kube-apiserver对<code>DELETE</code>动作的处理，即删除操作对应的具体的http handler。</p>
<p><a href="https://github.com/kubernetes/kubernetes/blob/99e36a93b2170292a4d7b675470cf64ce4fb4b56/staging/src/k8s.io/apiserver/pkg/endpoints/installer.go#L190">staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;endpoints&#x2F;installer.go</a>文件会对api资源的handler进行安装，绑定url与其对应的handler，其中<code>registerResourceHandlers</code>函数注册了<code>DELETE</code>对应的handler，部分代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;DELETE&quot;</span>: <span class="comment">// Delete a resource.</span></span><br><span class="line">    article := GetArticleForNoun(kind, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    doc := <span class="string">&quot;delete&quot;</span> + article + kind</span><br><span class="line">    <span class="keyword">if</span> isSubresource &#123;</span><br><span class="line">        doc = <span class="string">&quot;delete &quot;</span> + subresource + <span class="string">&quot; of&quot;</span> + article + kind</span><br><span class="line">    &#125;</span><br><span class="line">    deleteReturnType := versionedStatus</span><br><span class="line">    <span class="keyword">if</span> deleteReturnsDeletedObject &#123;</span><br><span class="line">        deleteReturnType = producedObject</span><br><span class="line">    &#125;</span><br><span class="line">    handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, restfulDeleteResource(gracefulDeleter, isGracefulDeleter, reqScope, admit))</span><br><span class="line">    <span class="keyword">if</span> enableWarningHeaders &#123;</span><br><span class="line">        handler = utilwarning.AddWarningsHandler(handler, warnings)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对应的handler即为<code>restfulDeleteResource</code>，最终该handler调用了<a href="https://github.com/kubernetes/kubernetes/blob/99e36a93b2170292a4d7b675470cf64ce4fb4b56/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go#L1002">staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;registry&#x2F;generic&#x2F;registry&#x2F;store.go</a>的DELETE方法，该方法会从请求参数中构造<code>DeleteOptions</code>参数，然后调用<a href="https://github.com/kubernetes/kubernetes/blob/99e36a93b2170292a4d7b675470cf64ce4fb4b56/staging/src/k8s.io/apiserver/pkg/registry/rest/delete.go#L75">staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;registry&#x2F;rest&#x2F;delete.go</a>的<code>rest.BeforeDelete</code>判断是否是优雅删除，主要逻辑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BeforeDelete</span><span class="params">(strategy RESTDeleteStrategy, ctx context.Context, obj runtime.Object, options *metav1.DeleteOptions)</span> <span class="params">(graceful, gracefulPending <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    gracefulStrategy, ok := strategy.(RESTGracefulDeleteStrategy)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">// If we&#x27;re not deleting gracefully there&#x27;s no point in updating Generation, as we won&#x27;t update</span></span><br><span class="line">        <span class="comment">// the obcject before deleting it.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 调用不同资源的设置的优雅删除策略设置优雅删除等参数</span></span><br><span class="line">    <span class="keyword">if</span> !gracefulStrategy.CheckGracefulDelete(ctx, obj, options) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重点：设置不同资源的DeletionTimestamp和DeletionGracePeriodSeconds，标记为删除状态</span></span><br><span class="line">    now := metav1.NewTime(metav1.Now().Add(time.Second * time.Duration(*options.GracePeriodSeconds)))</span><br><span class="line">    objectMeta.SetDeletionTimestamp(&amp;now)</span><br><span class="line">    objectMeta.SetDeletionGracePeriodSeconds(options.GracePeriodSeconds)</span><br></pre></td></tr></table></figure>

<p>该函数中首先会有另外一个回调来针对不同的资源设置不同的优雅删除策略，接口定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RESTGracefulDeleteStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// CheckGracefulDelete should return true if the object can be gracefully deleted and set</span></span><br><span class="line">    <span class="comment">// any default values on the DeleteOptions.</span></span><br><span class="line">    CheckGracefulDelete(ctx context.Context, obj runtime.Object, options *metav1.DeleteOptions) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里关注pod策略的具体实现，如果请求参数里设置了<code>GracePeriodSeconds</code>，则设置为用户指定的值，如果没有设置就使用pod的spec中<code>TerminationGracePeriodSeconds</code>字段设置的值，这个值默认为30s，是在pod创建的时候赋的，这也就解释了为什么使用<code>kubectl</code>删除时并未指定<code>gracePeriod</code>参数而实际上pod的<code>ObjectMeta</code>中的<code>DeletionGracePeriodSeconds</code>字段却被设置为了30s，这一现象可以通过<code>kubectl get po nginx-deployment-xxx -w -oyaml</code>观察pod删除过程中pod的<code>DeletionGracePeriodSeconds</code>值的变化来证实。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(podStrategy)</span> <span class="title">CheckGracefulDelete</span><span class="params">(ctx context.Context, obj runtime.Object, options *metav1.DeleteOptions)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 使用用户指定的优雅删除时间</span></span><br><span class="line">    <span class="keyword">if</span> options.GracePeriodSeconds != <span class="literal">nil</span> &#123;</span><br><span class="line">        period = *options.GracePeriodSeconds</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用pod设置的默认的TerminationGracePeriodSeconds值，默认为30s</span></span><br><span class="line">        <span class="keyword">if</span> pod.Spec.TerminationGracePeriodSeconds != <span class="literal">nil</span> &#123;</span><br><span class="line">            period = *pod.Spec.TerminationGracePeriodSeconds</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// ensure the options and the pod are in sync</span></span><br><span class="line">    options.GracePeriodSeconds = &amp;period</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来<code>BeforeDelete</code>的逻辑就是设置pod的<code>DeletionTimestamp</code>和<code>DeletionGracePeriodSeconds</code>字段值，然后更新后数据库，因此可以看到有了优雅删除，pod的删除其实被分成了两步，第一步是kube-apiserver仅仅更新了pod的两个字段，将pod标记为删除状态，其余的几乎什么也没干，因为kube-apisever并不感知pod中的container是否已经运行完毕可以kill，也不应该由kube-apiserver来负责管理，因此第二步就由节点上的kubelet来进行了。</p>
<p>顺便提一句，我们经常看到pod处于所谓的Terminating状态，其实这一状态在etcd中pod的具体字段中并不存在，而是kubectl get时可以在请求Header中设置Accept的具体值，当设置的value中有<code>as=table</code>时，kube-apiserver返回的是<code>Table</code>类型，即人类可读的格式，而这个Terminating状态就是kube-apiserver设置的一种转化形式，当资源的<code>DeletionTimestamp</code>不为空时，将<code>Table</code>中的Status设置为Terminating。</p>
<h1 id="kubelet行为"><a href="#kubelet行为" class="headerlink" title="kubelet行为"></a>kubelet行为</h1><p>kubelet通过informer监听本节点pod事件，kubelet启动时，syncLoop会处理所有的pod更新事件，然后根据不同的时间类型dispatch分发到podWorker进行处理，在每次处理中会将podStatus的变化放进一个channel，kubelet启动了一个异步的协程进专门进行podStatus变化的处理，消费该channel处理podStatus的变化，这部分逻辑由status_manager进行处理，status_manager在处理podStatus时调用syncPod方法进行处理，主要逻辑如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">syncPod</span><span class="params">(uid types.UID, status versionedPodStatus)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 判断是否可以删除从etcd中删除pod的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> m.canBeDeleted(pod, status.status) &#123;</span><br><span class="line">        deleteOptions := metav1.DeleteOptions&#123;</span><br><span class="line">            GracePeriodSeconds: <span class="built_in">new</span>(<span class="keyword">int64</span>),</span><br><span class="line">            <span class="comment">// Use the pod UID as the precondition for deletion to prevent deleting a</span></span><br><span class="line">            <span class="comment">// newly created pod with the same name and namespace.</span></span><br><span class="line">            Preconditions: metav1.NewUIDPreconditions(<span class="keyword">string</span>(pod.UID)),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置GracePeriodSeconds为0强制删除pod</span></span><br><span class="line">        err = m.kubeClient.CoreV1().Pods(pod.Namespace).Delete(context.TODO(), pod.Name, deleteOptions)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.InfoS(<span class="string">&quot;Failed to delete status for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;Pod fully terminated and removed from etcd&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">        m.deletePodStatus(uid)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的判断为canBeDeleted函数，其中就包含了对前文说的pod是否满足特定条件的判断，这些条件包括</p>
<ul>
<li>pod中的container不再running</li>
<li>从runtime侧获取的container被清理掉</li>
<li>pod挂载的volume被清理掉</li>
<li>container的cgroup被清理掉</li>
</ul>
<p>因此只有这些条件都被满足时，kuelet才会发送一个GracePeriodSeconds为0的deleteOptions给kube-apiserver，kube-apiserver此时才会真正从etcd中删除该pod，然后pod消失。</p>
<p>pod处于terminating原因分析</p>
<p>了解了pod结束Terminating的条件，再分析pod处于Terminating的原因就比较简单了。通常有以下原因</p>
<ul>
<li>kubelet与runtime的通信有问题，导致kuelet获取不到container状态或者更新podStatus状态失败</li>
<li>container由于某些原因无法清理，比如容器进程变成D状态，无法接受信号，导致container残留。</li>
<li>pod的volume卸载出错，比如csi场景下与csi通信出现问题，或者pod的volume出现重复挂载，而调用csi接口只卸载了一次，且在挂载时没有校验重复挂载。kubernetes1.20版本之后，在对csi类型的卷进行挂载操作时，把校验重复挂载的逻辑去掉了，社区认为校验重复挂载的逻辑应该由csi插件来做，因此如果csi插件没有检验重复挂载，则一旦kubelet重启进行了重复挂载，删除pod时由于只进行了一次卸载 ，导致pod挂载的卷仍然残留，从而阻塞pod删除，相关<a href="https://github.com/kubernetes/kubernetes/pull/88759">issue</a>见链接。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对pod的删除操作并不是我们想象的那样一次性删除，优雅删除的实现需要<code>kubectl/kube-apiserver/kubelet</code>的协作完成，通过对kubelet最终删除pod的流程进行分析，可以帮助我们快速分析到阻塞pod删除的原因，同时也学习到了kubernetes的优秀设计。</p>
]]></content>
      <tags>
        <tag>K8s</tag>
        <tag>Pod</tag>
        <tag>Terminating</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s workqueue实现分析</title>
    <url>/2022/03/30/workqueue/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>channel</code>是<code>go</code>协程间通信的主要方式，但使用channel时通常需要预设<code>channel</code>的buffer大小。在实际业务中，通常难以准确的预知需要的<code>channel</code>大小，若预设较大buffer的channel可能会造成内存浪费，若预设的buffer较小则可能造成处理任务的阻塞，而<code>channel</code>不支持动态扩容。因此需要一种动态调节缓冲大小的数据结构来支持协程间协作，<code>k8s</code>的<code>client-go</code>中提供了基于切片的支持线程安全的并发队列，解耦生产者与消费者，并且提供了去重、限速、重试加入队列等功能，代码简洁设计巧妙，可作为除<code>channel</code>外另一种便捷的协程通信手段。</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p><a href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go">k8s&#x2F;client-go代码仓</a>中以一个controller处理任务为例子，提供了<code>work queue</code>队列的官方example，<code>work queue</code>部分主要代码如下</p>
<h2 id="生产者部分"><a href="#生产者部分" class="headerlink" title="生产者部分"></a>生产者部分</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个work queue</span></span><br><span class="line">queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())</span><br><span class="line"><span class="comment">// 将一个待处理的对象添加work queue</span></span><br><span class="line">queue.Add(key)</span><br></pre></td></tr></table></figure>

<h2 id="消费者部分"><a href="#消费者部分" class="headerlink" title="消费者部分"></a>消费者部分</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// workers代表处理并发处work queue中任务的协程数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> wait.Until(c.runWorker, time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// runWorker是一个死循环，通过processNextItem从队列中取出key进行处理，然后取出next key继续处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">runWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> c.processNextItem() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// processNextItem就是真正的处理逻辑了，</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">processNextItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// quit为true代表队列已关闭</span></span><br><span class="line">    key, quit := c.queue.Get()</span><br><span class="line">    <span class="keyword">if</span> quit &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理完后将key从队列中移除，并且该操作是并发安全的，后续会进行详细分析</span></span><br><span class="line">    <span class="keyword">defer</span> c.queue.Done(key)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用实际业务代码对每个key进行处理</span></span><br><span class="line">    err := c.syncToStdout(key.(<span class="keyword">string</span>))</span><br><span class="line">    <span class="comment">// 如果处理异常则进行错误处理</span></span><br><span class="line">    c.handleErr(err, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误处理代码，对上一函数中可能处理失败的key进行重试等操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">handleErr</span><span class="params">(err error, key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果处理没有错误，调用Forget方法将key从限速队列中移除</span></span><br><span class="line">        c.queue.Forget(key)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// NumRequeues方法返回了一个key重入队列的次数，若超过设定的阈值，则从限速队列中移除，不再处理</span></span><br><span class="line">    <span class="keyword">if</span> c.queue.NumRequeues(key) &lt; <span class="number">5</span> &#123;</span><br><span class="line">        klog.Infof(<span class="string">&quot;Error syncing pod %v: %v&quot;</span>, key, err)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 若重入队列次数没超过阈值，则添加到限速队列</span></span><br><span class="line">        c.queue.AddRateLimited(key)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    c.queue.Forget(key)</span><br><span class="line">    <span class="comment">// 错误上报</span></span><br><span class="line">    runtime.HandleError(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>work queue</code>的使用比较简单，且官方已经给了使用模板，调用者不需要处理元素去重、重入队列、并发安全、错误处理等逻辑，只需关注自己的业务即可。</p>
<p>限速队列由多个队列一起完成，下文将逐一介绍其具体实现。</p>
<h1 id="基本队列work-queue"><a href="#基本队列work-queue" class="headerlink" title="基本队列work queue"></a>基本队列<code>work queue</code></h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>该<code>Interface</code>定义了一个最基本的队列的基本方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    Add(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// 队列长度</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回队首元素，并返队列队列是否关闭</span></span><br><span class="line">    Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// 处理完一个元素后从队列中删除</span></span><br><span class="line">    Done(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// 关闭队列</span></span><br><span class="line">    ShutDown()</span><br><span class="line">    <span class="comment">// 返回队列是否关闭</span></span><br><span class="line">    ShuttingDown() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// interface&#123;&#125;类型的切片，存储具体的key</span></span><br><span class="line">    queue []t</span><br><span class="line">    <span class="comment">// 存储需要被处理的元素</span></span><br><span class="line">    dirty set</span><br><span class="line">    <span class="comment">// 存储正在处理的元素</span></span><br><span class="line">    processing set</span><br><span class="line">    <span class="comment">// 用于唤醒其他协程队列已满足条件可以继续处理，如队列由空变为非空</span></span><br><span class="line">    cond *sync.Cond</span><br><span class="line">    <span class="comment">// 标记队列是否关闭</span></span><br><span class="line">    shuttingDown <span class="keyword">bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监控指标相关字段</span></span><br><span class="line">    metrics queueMetrics</span><br><span class="line">    unfinishedWorkUpdatePeriod time.Duration</span><br><span class="line">    clock                      clock.Clock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重点介绍下<code>shutdown</code>标记，该标记主要为了通知其他<code>goroutine</code>如消费者、监控组件等队列是否关闭状态，其他<code>goroutine</code>处理是检查到队列为关闭状态时停止工作，避免发生未知错误。</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a><code>Add</code></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">Add</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加锁互斥保证线程安全</span></span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    <span class="keyword">if</span> q.shuttingDown &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录监控指标</span></span><br><span class="line">    q.metrics.add(item)</span><br><span class="line">    </span><br><span class="line">    q.dirty.insert(item)</span><br><span class="line">    <span class="comment">// 当有相同元素正在处理时，同样进行去重操作，不予入队</span></span><br><span class="line">    <span class="keyword">if</span> q.processing.has(item) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终添加到队列</span></span><br><span class="line">    q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">    q.cond.Signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Add</code>方法会先key放入<code>dirty</code>和queue中，加入时都会对这两个字段存储的元素进行去重操作，同时若该key正在被处理，则不会加入，防止同一时刻有同一个key被多个worker处理，从而导致业务逻辑错误。所以dirty集合的设计既有去重功能，又保证一个元素至多被处理一次。</p>
<h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a><code>Get</code></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    <span class="comment">// 如果队列元素为空且没有关闭则等待其他goroutine唤醒</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &amp;&amp; !q.shuttingDown &#123;</span><br><span class="line">        q.cond.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若已经关闭则应该返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// We must be shutting down.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从queue字段取出一个元素</span></span><br><span class="line">    item, q.queue = q.queue[<span class="number">0</span>], q.queue[<span class="number">1</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监控相关</span></span><br><span class="line">    q.metrics.get(item)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把key加入processing集合并从dirty删除，这样相同的key可以在当前key处理完后继续入队处理</span></span><br><span class="line">    q.processing.insert(item)</span><br><span class="line">    q.dirty.<span class="built_in">delete</span>(item)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> item, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Get</code>操作也比较简单，需要注意的是Get时key也会从dirty集合中移除</p>
<h4 id="Done-amp-ShutDown"><a href="#Done-amp-ShutDown" class="headerlink" title="Done &amp; ShutDown"></a><code>Done</code> &amp; <code>ShutDown</code></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">Done</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    </span><br><span class="line">    q.metrics.done(item)</span><br><span class="line">    </span><br><span class="line">    q.processing.<span class="built_in">delete</span>(item)</span><br><span class="line">    <span class="comment">// 若key在处理的过程中，又再次被加入到队列，由Add方法可知，当key在processing中时，Add操作只是把key放到了dirty集合，并没有放入queue中，因此</span></span><br><span class="line">    <span class="comment">// 相同的key处理完从processing中移除后，需要把key再放入到queue中，防止key被遗漏</span></span><br><span class="line">    <span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">        q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">        q.cond.Signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">ShutDown</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    q.shuttingDown = <span class="literal">true</span></span><br><span class="line">    q.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是<code>work queue</code>的基本逻辑，可以看到通过设置dirty和processing两个集合，<code>work queue</code>实现了去重功能，并防止了相同key被同时处理的错误。接下来将介绍<code>work queue</code>如何实现延迟已经限速。</p>
<h1 id="延迟队列DelayingQueue"><a href="#延迟队列DelayingQueue" class="headerlink" title="延迟队列DelayingQueue"></a>延迟队列<code>DelayingQueue</code></h1><h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DelayingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Interface</span><br><span class="line">    <span class="comment">// 经过duration时间后item被重新加入队列</span></span><br><span class="line">    AddAfter(item <span class="keyword">interface</span>&#123;&#125;, duration time.Duration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延迟队列在上文介绍的<code>work queue</code>基础上实现，继承了<code>Interface</code>接口，多了一个<code>AddAfter</code>方法，通过设置指定的duration来达到限速的目的。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDelayingQueue</span><span class="params">(clock clock.Clock, q Interface, name <span class="keyword">string</span>)</span> *<span class="title">delayingType</span></span> &#123;</span><br><span class="line">    ret := &amp;delayingType&#123;</span><br><span class="line">        Interface:       q,</span><br><span class="line">        clock:           clock,</span><br><span class="line">        heartbeat:       clock.NewTicker(maxWait),</span><br><span class="line">        stopCh:          <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        waitingForAddCh: <span class="built_in">make</span>(<span class="keyword">chan</span> *waitFor, <span class="number">1000</span>),</span><br><span class="line">        metrics:         newRetryMetrics(name),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> ret.waitingLoop()</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newDelayingQueue</code>返回一个<code>delayingType</code>类型的限速队列，同时会启动一个<code>waitingLoop</code>协程处理被添加的key，接下来详细分析<code>AddAfter</code>和<code>waitingLoop</code>的实现。</p>
<h3 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h3><h4 id="AddAfter"><a href="#AddAfter" class="headerlink" title="AddAfter"></a><code>AddAfter</code></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *delayingType)</span> <span class="title">AddAfter</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, duration time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> q.ShuttingDown() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    q.metrics.retry()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有延迟直接加入queue</span></span><br><span class="line">    <span class="keyword">if</span> duration &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        q.Add(item)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-q.stopCh:</span><br><span class="line">        <span class="comment">// 将封装后的key放入waitingForAddCh channel</span></span><br><span class="line">    <span class="keyword">case</span> q.waitingForAddCh &lt;- &amp;waitFor&#123;data: item, readyAt: q.clock.Now().Add(duration)&#125;:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AddAfter</code>的主要逻辑就是将key和key的延迟时间封装成一个<code>waitFor</code> <code>struct</code>，其中<code>readyAt</code>即为key应该加入到队列的时间，然后将该<code>struct</code>放入到<code>waitingForAddCh</code>中，<code>waitingLoop</code>协程会异步进行处理。默认<code>waitingForAddCh</code>的大小为1000，当<code>channel</code>满时添加key会被block。</p>
<h4 id="waitingLoop"><a href="#waitingLoop" class="headerlink" title="waitingLoop"></a><code>waitingLoop</code></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *delayingType)</span> <span class="title">waitingLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    </span><br><span class="line">    never := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> time.Time)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录等待队列中第一个key需要的等待的时间</span></span><br><span class="line">    <span class="keyword">var</span> nextReadyAtTimer clock.Timer</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  基于堆实现的优先级队列，需要最早被加入到队列的key放在最前面</span></span><br><span class="line">    waitingForQueue := &amp;waitForPriorityQueue&#123;&#125;</span><br><span class="line">    heap.Init(waitingForQueue)</span><br><span class="line">    </span><br><span class="line">    waitingEntryByData := <span class="keyword">map</span>[t]*waitFor&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> q.Interface.ShuttingDown() &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        now := q.clock.Now()</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断堆顶元素是否到期需要加入队列</span></span><br><span class="line">        <span class="keyword">for</span> waitingForQueue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">            entry := waitingForQueue.Peek().(*waitFor)</span><br><span class="line">            <span class="comment">// 如果还没到期，继续等待或者继续监听后续key加入事件</span></span><br><span class="line">            <span class="keyword">if</span> entry.readyAt.After(now) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 从堆顶弹出元素添加到队列</span></span><br><span class="line">            entry = heap.Pop(waitingForQueue).(*waitFor)</span><br><span class="line">            q.Add(entry.data)</span><br><span class="line">            <span class="built_in">delete</span>(waitingEntryByData, entry.data)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        nextReadyAt := never</span><br><span class="line">        <span class="keyword">if</span> waitingForQueue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nextReadyAtTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">                nextReadyAtTimer.Stop()</span><br><span class="line">            &#125;</span><br><span class="line">            entry := waitingForQueue.Peek().(*waitFor)</span><br><span class="line">            nextReadyAtTimer = q.clock.NewTimer(entry.readyAt.Sub(now))</span><br><span class="line">            nextReadyAt = nextReadyAtTimer.C()</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-q.stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 等待心跳时间过期</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-q.heartbeat.C():</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 等待对顶元素时间过期</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-nextReadyAt:</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 从waitingForAddCh中取元素，若已经到期直接加入到队列，否则加入堆中等待处理</span></span><br><span class="line">        <span class="keyword">case</span> waitEntry := &lt;-q.waitingForAddCh:</span><br><span class="line">            <span class="keyword">if</span> waitEntry.readyAt.After(q.clock.Now()) &#123;</span><br><span class="line">                insert(waitingForQueue, waitingEntryByData, waitEntry)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.Add(waitEntry.data)</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 尝试再取一个</span></span><br><span class="line">            drained := <span class="literal">false</span></span><br><span class="line">            <span class="keyword">for</span> !drained &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> waitEntry := &lt;-q.waitingForAddCh:</span><br><span class="line">                    <span class="keyword">if</span> waitEntry.readyAt.After(q.clock.Now()) &#123;</span><br><span class="line">                        insert(waitingForQueue, waitingEntryByData, waitEntry)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q.Add(waitEntry.data)</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    drained = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>waitingLoop</code>监听<code>waitingForAddCh</code> <code>channel</code>，从中取出待添加到队列的key，如果已经到期则直接加入，否则将key放入到堆中，然后每次从堆中取出最先过期的key进行判断处理。</p>
<h1 id="限速队列RateLimitingQueue"><a href="#限速队列RateLimitingQueue" class="headerlink" title="限速队列RateLimitingQueue"></a>限速队列<code>RateLimitingQueue</code></h1><h2 id="接口-2"><a href="#接口-2" class="headerlink" title="接口"></a>接口</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RateLimitingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    DelayingInterface</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 限速器rate limiter指定的时间到期后将item加入队列</span></span><br><span class="line">    AddRateLimited(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将item从限速器删除，不再进行重试加入，但还是需要调用Done方法删除item</span></span><br><span class="line">    Forget(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回item被重新入队列的次数</span></span><br><span class="line">    NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RateLimitingInterface</code>同样是在·的基础上多了三个方法，使用限速队列时需要调用<code>NewNamedRateLimitingQueue</code>方法传入<code>RateLimiter</code>，调用时可以传入不同的限速器<code>ratelimiter</code>实现，官方提供了四种rate Limiter实现，分别是<code>BucketRateLimiter</code>、<code>ItemExponentialFailureRateLimiter</code>、<code>ItemFastSlowRateLimiter</code>和<code>MaxOfRateLimiter。</code></p>
<p><code>RateLimiter</code>需要实现三个方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RateLimiter <span class="keyword">interface</span> &#123;</span><br><span class="line">   <span class="comment">// 返回key需要等待加入队列的时间</span></span><br><span class="line">   When(item <span class="keyword">interface</span>&#123;&#125;) time.Duration</span><br><span class="line">   <span class="comment">// 取消key的重试</span></span><br><span class="line">   Forget(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">   <span class="comment">// 记录一个key被重试了多少次</span></span><br><span class="line">   NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BucketRateLimiter"><a href="#BucketRateLimiter" class="headerlink" title="BucketRateLimiter"></a><code>BucketRateLimiter</code></h2><p><code>BucketRateLimiter</code>是基于token令牌桶的限速方法，通过三方库<code>golang.org/x/time/rate</code>实现，令牌桶的算法原理是将固定数目的token放入桶中，桶满时则不再添加，然后元素需要拿到token才能被处理，后续元素需要等待有空闲的token被释放。使用时通过如下代码初始化一个令牌桶。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rate.NewLimiter(rate.Limit(<span class="number">10</span>), <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>10代表每秒往桶中放入token的数量，100代表token数量，加入有102个元素在，则前100个元素直接通过，而对于第100个元素，由于每秒放入10个token，因此处理一个token需要<code>100ms</code>，所以第101个元素需要等待<code>100ms</code>，同理第102个元素需要等待<code>200ms</code>。</p>
<h2 id="ItemExponentialFailureRateLimiter"><a href="#ItemExponentialFailureRateLimiter" class="headerlink" title="ItemExponentialFailureRateLimiter"></a><code>ItemExponentialFailureRateLimiter</code></h2><p><code>ItemExponentialFailureRateLimiter</code>就是指数退避算法，有两个主要参数<code>baseDelay</code>，<code>maxDelay</code>，<code>baseDelay</code>代表需要推迟的基数，每次添加相同的key其对应的延迟加入时间会指数递增，但也不能无限递增，因此<code>maxDelay</code>规定了延迟时间的上限。指数退避部分主要代码如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次进来exp指数加1</span></span><br><span class="line">exp := r.failures[item]</span><br><span class="line">r.failures[item] = r.failures[item] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">backoff := <span class="keyword">float64</span>(r.baseDelay.Nanoseconds()) * math.Pow(<span class="number">2</span>, <span class="keyword">float64</span>(exp))</span><br><span class="line"><span class="keyword">if</span> backoff &gt; math.MaxInt64 &#123;</span><br><span class="line">   <span class="keyword">return</span> r.maxDelay</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利润<code>baseDelay</code>为10，<code>maxDelay</code>为1000，同一个key第一次进行需要等待的时间为10*2^1，第二次为10*2^2，以此类推。</p>
<h2 id="ItemFastSlowRateLimiter"><a href="#ItemFastSlowRateLimiter" class="headerlink" title="ItemFastSlowRateLimiter"></a><code>ItemFastSlowRateLimiter</code></h2><p><code>ItemFastSlowRateLimiter</code>定义了两个时间<code>fastDelay</code>、<code>lowDelay</code>以及达到<code>fastDelay</code>的阈值<code>maxFastAttempts。</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.failures[item] = r.failures[item] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r.failures[item] &lt;= r.maxFastAttempts &#123;</span><br><span class="line">   <span class="keyword">return</span> r.fastDelay</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r.slowDelay</span><br></pre></td></tr></table></figure>

<p>当重新加入队列的次数小于阈值<code>maxFastAttempts</code>，需要等待的时间为<code>fastDelay</code>，超过阈值则需要等待更长的时间<code>slowDelay。</code></p>
<h2 id="MaxOfRateLimiter"><a href="#MaxOfRateLimiter" class="headerlink" title="MaxOfRateLimiter"></a><code>MaxOfRateLimiter</code></h2><p><code>MaxOfRateLimiter</code>则是多个<code>RateLimiter</code>的组合，需要延迟的时间为各个<code>RateLimiter</code>的时间最大值。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>client-go</code>的<code>work queue</code>首先实现了一个最基础的队列，包含最基本的<code>Add</code>、<code>Get</code>等方法，然后在该队列基础上实现了<code>DelayingQueue</code>，实现了延迟队列的功能，最后在延迟队列的基础上实现了<code>RateLimitingQueue</code>，层层嵌套，最终实现了功能完善的限速队列，使得使用者只需关注业务逻辑，不需要自己实现底层逻辑。</p>
]]></content>
      <tags>
        <tag>K8s</tag>
        <tag>源码</tag>
        <tag>workqueue</tag>
      </tags>
  </entry>
  <entry>
    <title>Etcd watch机制详解</title>
    <url>/2022/03/30/etcd-watch/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>watch机制是etcd设计的一大特色，客户端通过监听指定的key可以迅速感知key的变化并作出相应处理，watch机制的实现依赖于资源版本号revision的设计，每一次key的更新都会使得revision原子递增，因此根据不同的版本号revision的对比就可以感知新事件的发生。etcd watch机制有着广泛的应用，比如利用etcd实现分布式锁；k8s中监听各种资源的变化，从而实现各种controller逻辑等。</p>
<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p><img src="/2022/03/30/etcd-watch/process.png" alt="整体流程"></p>
<p>watch机制的实现主要可分为三个部分，分别是客户端gRPC调用、server端gRPC处理以及从底层存储获取更新事件。client使用<code>watchClient</code>的watch接口发起watch请求，与server端建立一个<code>gRPCStream</code>连接，server端会为每个client生成唯一一个watch id，并记录每个client也就是watcher监听的key或者key range，通过recvLoop接收client请求，通过sendLoop发送请求，server端只负责收发请求和响应，主要的实现都放在了watchalbStore层。watchalbStore会监听key的变化，然后通过syncWatchersLoop和syncVictimsLoop两个处理流程将key的更新变化包装成event，通过channel发送给gRPC server，具体来说，watchableStore会在每次处理事务时都会回调一个通知函数，该函数将每次的key更新事件与客户端监听的key进行值和revision的比对，一旦相应的key有变化，就会把这些更新推送给server端，然后server通过gRPC将更新事件再发送到客户端，从而实现客户端总是能实时感知到key的变化，整个流程做到闭环。</p>
<h1 id="client请求"><a href="#client请求" class="headerlink" title="client请求"></a>client请求</h1><p>根据<code>etcdserver/etcdserverpb/rpc.pb.go</code>的定义，client端调用<code>NewWatchClient</code>生成一个watchClient，然后调用Watch方法生成一个<code>Watch_WatchClient</code>的client。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WatchClient <span class="keyword">interface</span> &#123;</span><br><span class="line">   <span class="comment">// Watch watches for events happening or that have happened. Both input and output</span></span><br><span class="line">   <span class="comment">// are streams; the input stream is for creating and canceling watchers and the output</span></span><br><span class="line">   <span class="comment">// stream sends events. One watch RPC can watch on multiple key ranges, streaming events</span></span><br><span class="line">   <span class="comment">// for several watches at once. The entire event history can be watched starting from the</span></span><br><span class="line">   <span class="comment">// last compaction revision.</span></span><br><span class="line">   Watch(ctx context.Context, opts ...grpc.CallOption) (Watch_WatchClient, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> watchClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    cc *grpc.ClientConn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWatchClient</span><span class="params">(cc *grpc.ClientConn)</span> <span class="title">WatchClient</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;watchClient&#123;cc&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *watchClient)</span> <span class="title">Watch</span><span class="params">(ctx context.Context, opts ...grpc.CallOption)</span> <span class="params">(Watch_WatchClient, error)</span></span> &#123;</span><br><span class="line">    stream, err := grpc.NewClientStream(ctx, &amp;_Watch_serviceDesc.Streams[<span class="number">0</span>], c.cc, <span class="string">&quot;/etcdserverpb.Watch/Watch&quot;</span>, opts...)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    x := &amp;watchWatchClient&#123;stream&#125;</span><br><span class="line">    <span class="keyword">return</span> x, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Watch_WatchClient</code>接口定义了两个方法，分别是发送&#x2F;接收watch请求的Send和Recv。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Watch_WatchClient <span class="keyword">interface</span> &#123;</span><br><span class="line">   Send(*WatchRequest) error</span><br><span class="line">   Recv() (*WatchResponse, error)</span><br><span class="line">   grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端只需调用Watch接口即可建立一个watch请求，底层的gRPCStream连接已由gRPC自动建立，client端只需关注watch请求和返回值即可。</p>
<h1 id="server端处理"><a href="#server端处理" class="headerlink" title="server端处理"></a>server端处理</h1><p>server端进行处理的结构体为watchServer，代码位置<code>etcdserver/api/v3rpc/watch.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> watchServer <span class="keyword">struct</span> &#123;</span><br><span class="line">   lg *zap.Logger</span><br><span class="line"></span><br><span class="line">   clusterID <span class="keyword">int64</span></span><br><span class="line">   memberID  <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">   maxRequestBytes <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   sg        etcdserver.RaftStatusGetter</span><br><span class="line">   <span class="comment">// 实现: watchable_store.go watchableStore</span></span><br><span class="line">   watchable mvcc.WatchableKV</span><br><span class="line">   ag        AuthGetter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>watchable</code>是关键字段，具体实现即为store层<code>watchableStore</code>，是整个watch时间的最底层来源，后面会具体介绍，这里仅先关注gRPC server端的处理流程。</p>
<p><code>NewWatchServer</code>在初始化时会建立<code>watchableStore</code>，然后就是具体的Watch方法实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *watchServer)</span> <span class="title">Watch</span><span class="params">(stream pb.Watch_WatchServer)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">   sws := serverWatchStream&#123;</span><br><span class="line">      maxRequestBytes: ws.maxRequestBytes,</span><br><span class="line">      watchable: ws.watchable,</span><br><span class="line">     <span class="comment">// gRPC连接</span></span><br><span class="line">      gRPCStream:  stream,</span><br><span class="line">      watchStream: ws.watchable.NewWatchStream(),</span><br><span class="line">      <span class="comment">// chan for sending control response like watcher created and canceled.</span></span><br><span class="line">      ctrlStream: <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.WatchResponse, ctrlStreamBufLen),</span><br><span class="line">      progress: <span class="built_in">make</span>(<span class="keyword">map</span>[mvcc.WatchID]<span class="keyword">bool</span>),</span><br><span class="line">      prevKV:   <span class="built_in">make</span>(<span class="keyword">map</span>[mvcc.WatchID]<span class="keyword">bool</span>),</span><br><span class="line">      fragment: <span class="built_in">make</span>(<span class="keyword">map</span>[mvcc.WatchID]<span class="keyword">bool</span>),</span><br><span class="line">      closec: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sws.wg.Add(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="comment">// 发送watch相应到client</span></span><br><span class="line">      sws.sendLoop()</span><br><span class="line">      sws.wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   errc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 从client端接收watch请求</span></span><br><span class="line">      <span class="keyword">if</span> rerr := sws.recvLoop(); rerr != <span class="literal">nil</span> &#123;</span><br><span class="line">         errc &lt;- rerr</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> err = &lt;-errc:</span><br><span class="line">      <span class="built_in">close</span>(sws.ctrlStream)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> &lt;-stream.Context().Done():</span><br><span class="line">      err = stream.Context().Err()</span><br><span class="line">      <span class="comment">// the only server-side cancellation is noleader for now.</span></span><br><span class="line">      <span class="keyword">if</span> err == context.Canceled &#123;</span><br><span class="line">         err = rpctypes.ErrGRPCNoLeader</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sws.<span class="built_in">close</span>()</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化下代码可以看到server端会首先新建一个serverWatchStream，然后通过两个主要的goroutine recvLoop和sendLoop进行处理，分别进行watch请求的接收和响应。</p>
<h2 id="recvLoop"><a href="#recvLoop" class="headerlink" title="recvLoop"></a>recvLoop</h2><p><code>recvLoop</code>会处理三种watch请求</p>
<ul>
<li>CreateRequest 创建新请求</li>
<li>CancelRequest 取消请求</li>
<li>ProgressRequest 查看watch进度</li>
</ul>
<h3 id="创建新的watch请求"><a href="#创建新的watch请求" class="headerlink" title="创建新的watch请求"></a>创建新的watch请求</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sws *serverWatchStream)</span> <span class="title">recvLoop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      req, err := sws.gRPCStream.Recv()</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> uv := req.RequestUnion.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建watch请求</span></span><br><span class="line">      <span class="keyword">case</span> *pb.WatchRequest_CreateRequest:</span><br><span class="line">         <span class="keyword">if</span> uv.CreateRequest == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 确定watch key的begin-end范围</span></span><br><span class="line">         creq := uv.CreateRequest</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(creq.Key) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// \x00 is the smallest key</span></span><br><span class="line">            creq.Key = []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(creq.RangeEnd) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// force nil since watchstream.Watch distinguishes</span></span><br><span class="line">            <span class="comment">// between nil and []byte&#123;&#125; for single key / &gt;=</span></span><br><span class="line">            creq.RangeEnd = <span class="literal">nil</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(creq.RangeEnd) == <span class="number">1</span> &amp;&amp; creq.RangeEnd[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// support  &gt;= key queries</span></span><br><span class="line">            creq.RangeEnd = []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从context里获取username校验用户是否在请求的range key范围内有权限</span></span><br><span class="line">         <span class="keyword">if</span> !sws.isWatchPermitted(creq) &#123;</span><br><span class="line">            wr := &amp;pb.WatchResponse&#123;</span><br><span class="line">               Header:       sws.newResponseHeader(sws.watchStream.Rev()),</span><br><span class="line">               WatchId:      creq.WatchId,</span><br><span class="line">               Canceled:     <span class="literal">true</span>,</span><br><span class="line">               Created:      <span class="literal">true</span>,</span><br><span class="line">               CancelReason: rpctypes.ErrGRPCPermissionDenied.Error(),</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> sws.ctrlStream &lt;- wr:</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-sws.closec:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 过滤客户端指定的事件，PUT/DELETE</span></span><br><span class="line">         filters := FiltersFromRequest(creq)</span><br><span class="line"></span><br><span class="line">         wsrev := sws.watchStream.Rev()</span><br><span class="line">         rev := creq.StartRevision</span><br><span class="line">         <span class="keyword">if</span> rev == <span class="number">0</span> &#123;</span><br><span class="line">            rev = wsrev + <span class="number">1</span></span><br><span class="line">         &#125;</span><br><span class="line">         id, err := sws.watchStream.Watch(mvcc.WatchID(creq.WatchId), creq.Key, creq.RangeEnd, rev, filters...)</span><br><span class="line">         <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            sws.mu.Lock()</span><br><span class="line">            <span class="keyword">if</span> creq.ProgressNotify &#123;</span><br><span class="line">               sws.progress[id] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> creq.PrevKv &#123;</span><br><span class="line">               sws.prevKV[id] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> creq.Fragment &#123;</span><br><span class="line">               sws.fragment[id] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            sws.mu.Unlock()</span><br><span class="line">         &#125;</span><br><span class="line">         wr := &amp;pb.WatchResponse&#123;</span><br><span class="line">            Header:   sws.newResponseHeader(wsrev),</span><br><span class="line">            WatchId:  <span class="keyword">int64</span>(id),</span><br><span class="line">            Created:  <span class="literal">true</span>,</span><br><span class="line">            Canceled: err != <span class="literal">nil</span>,</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            wr.CancelReason = err.Error()</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> sws.ctrlStream &lt;- wr:</span><br><span class="line">         <span class="keyword">case</span> &lt;-sws.closec:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server端会根据creq请求参数的Key和RangeEnd确定请求的key的范围，然后从请求中取出authInfo认证信息校验请求用户对请求的key是否有权限，校验通过后生成包含revision和和watchID的watchResponse到client端，这里的发送是异步的，只是将watchResponse发送到serverWatchStream的ctrlStream channel里，由sendLoop协程发送到client。然后会过滤掉客户端指定的事件，比如删除、更新事件。</p>
<p>最后会调用watchStream的watch方法进行key的二次校验，生成watcherID并记录每一个watcher。并为每一个watcher生成一个cancel函数并存储在cancels map中，代码位置<code>mvcc/watcher.go</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> watchStream <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// 实现: mvcc/watchable_store.go watchableStore</span></span><br><span class="line">   watchable watchable</span><br><span class="line">   ch        <span class="keyword">chan</span> WatchResponse</span><br><span class="line"></span><br><span class="line">   mu sync.Mutex <span class="comment">// guards fields below it</span></span><br><span class="line">   <span class="comment">// nextID is the ID pre-allocated for next new watcher in this stream</span></span><br><span class="line">   <span class="comment">// 当客户端未指定watch id时，会用next id自动分配一个id</span></span><br><span class="line">   nextID   WatchID</span><br><span class="line">   closed   <span class="keyword">bool</span></span><br><span class="line">   cancels  <span class="keyword">map</span>[WatchID]cancelFunc</span><br><span class="line">   watchers <span class="keyword">map</span>[WatchID]*watcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Watch creates a new watcher in the stream and returns its WatchID.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *watchStream)</span> <span class="title">Watch</span><span class="params">(id WatchID, key, end []<span class="keyword">byte</span>, startRev <span class="keyword">int64</span>, fcs ...FilterFunc)</span> <span class="params">(WatchID, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">// prevent wrong range where key &gt;= end lexicographically</span></span><br><span class="line">   <span class="comment">// watch request with &#x27;WithFromKey&#x27; has empty-byte range end</span></span><br><span class="line">   <span class="comment">// key的字母序不能大于等于end</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(end) != <span class="number">0</span> &amp;&amp; bytes.Compare(key, end) != <span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>, ErrEmptyWatcherRange</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ws.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> ws.mu.Unlock()</span><br><span class="line">   <span class="keyword">if</span> ws.closed &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>, ErrEmptyWatcherRange</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> id == AutoWatchID &#123;</span><br><span class="line">      <span class="keyword">for</span> ws.watchers[ws.nextID] != <span class="literal">nil</span> &#123;</span><br><span class="line">         ws.nextID++</span><br><span class="line">      &#125;</span><br><span class="line">      id = ws.nextID</span><br><span class="line">      ws.nextID++</span><br><span class="line">      <span class="comment">// 校验watch id不能重复</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := ws.watchers[id]; ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>, ErrWatcherDuplicateID</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   w, c := ws.watchable.watch(key, end, startRev, id, ws.ch, fcs...)</span><br><span class="line"></span><br><span class="line">   ws.cancels[id] = c</span><br><span class="line">   ws.watchers[id] = w</span><br><span class="line">   <span class="keyword">return</span> id, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消watch请求"><a href="#取消watch请求" class="headerlink" title="取消watch请求"></a>取消watch请求</h3><p>取消watch请求会调用watchStream的Cancel函数删除watcher记录，并调用创建watch请求时每个watcher对应的cancel函数进行事件清理工作。然后同样将watchResponse发送给client端。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sws *serverWatchStream)</span> <span class="title">recvLoop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      req, err := sws.gRPCStream.Recv()</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> uv := req.RequestUnion.(<span class="keyword">type</span>) &#123;</span><br><span class="line">         <span class="comment">// 取消watch请求</span></span><br><span class="line">      <span class="keyword">case</span> *pb.WatchRequest_CancelRequest:</span><br><span class="line">         <span class="keyword">if</span> uv.CancelRequest != <span class="literal">nil</span> &#123;</span><br><span class="line">            id := uv.CancelRequest.WatchId</span><br><span class="line">            err := sws.watchStream.Cancel(mvcc.WatchID(id))</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="comment">// 发送</span></span><br><span class="line">               sws.ctrlStream &lt;- &amp;pb.WatchResponse&#123;</span><br><span class="line">                  Header:   sws.newResponseHeader(sws.watchStream.Rev()),</span><br><span class="line">                  WatchId:  id,</span><br><span class="line">                  Canceled: <span class="literal">true</span>,</span><br><span class="line">               &#125;</span><br><span class="line">               sws.mu.Lock()</span><br><span class="line">               <span class="built_in">delete</span>(sws.progress, mvcc.WatchID(id))</span><br><span class="line">               <span class="built_in">delete</span>(sws.prevKV, mvcc.WatchID(id))</span><br><span class="line">               <span class="built_in">delete</span>(sws.fragment, mvcc.WatchID(id))</span><br><span class="line">               sws.mu.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *watchStream)</span> <span class="title">Cancel</span><span class="params">(id WatchID)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   ws.mu.Lock()</span><br><span class="line">   cancel, ok := ws.cancels[id]</span><br><span class="line">   w := ws.watchers[id]</span><br><span class="line">   ok = ok &amp;&amp; !ws.closed</span><br><span class="line">   ws.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> ErrWatcherNotExist</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 调用创建watch请求时指定的cancel回调函数进行event清理工作</span></span><br><span class="line">   cancel()</span><br><span class="line"></span><br><span class="line">   ws.mu.Lock()</span><br><span class="line">   <span class="comment">// The watch isn&#x27;t removed until cancel so that if Close() is called,</span></span><br><span class="line">   <span class="comment">// it will wait for the cancel. Otherwise, Close() could close the</span></span><br><span class="line">   <span class="comment">// watch channel while the store is still posting events.</span></span><br><span class="line">   <span class="keyword">if</span> ww := ws.watchers[id]; ww == w &#123;</span><br><span class="line">      <span class="built_in">delete</span>(ws.cancels, id)</span><br><span class="line">      <span class="built_in">delete</span>(ws.watchers, id)</span><br><span class="line">   &#125;</span><br><span class="line">   ws.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询watch请求进度"><a href="#查询watch请求进度" class="headerlink" title="查询watch请求进度"></a>查询watch请求进度</h3><p>查询watch请求会返回当前的revision给client端。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sws *serverWatchStream)</span> <span class="title">recvLoop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      req, err := sws.gRPCStream.Recv()</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">switch</span> uv := req.RequestUnion.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="comment">// 查询watch请求进度，返回当前的revision</span></span><br><span class="line">      <span class="keyword">case</span> *pb.WatchRequest_ProgressRequest:</span><br><span class="line">         <span class="keyword">if</span> uv.ProgressRequest != <span class="literal">nil</span> &#123;</span><br><span class="line">            sws.ctrlStream &lt;- &amp;pb.WatchResponse&#123;</span><br><span class="line">               Header:  sws.newResponseHeader(sws.watchStream.Rev()),</span><br><span class="line">               WatchId: <span class="number">-1</span>, <span class="comment">// response is not associated with any WatchId and will be broadcast to all watch channels</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="comment">// we probably should not shutdown the entire stream when</span></span><br><span class="line">         <span class="comment">// receive an valid command.</span></span><br><span class="line">         <span class="comment">// so just do nothing instead.</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sendLoop"><a href="#sendLoop" class="headerlink" title="sendLoop"></a>sendLoop</h2><p><code>recvLoop</code>处理完三种请求后只是将watchResponse信息放在了channel中，真正的发送是在<code>sendLoop</code>中实现的，而且以上三种请求的watchResponse信息里压根没有event信息，因此sendLoop主要从两个channel里读取信息发送给client端，一个可以理解为watchResponse Header，即ctrlStream channel，一个就是真正的event信息<code>ws.watchStream.Chan()</code> channel。</p>
<p>event事件信息来自于<code>ws.watchStream.Chan()</code>的channel，这个channel数据来源就是store层也就是watchableStore层传递上来的，我们将最后梳理这部分的逻辑，这里仍然只关注gRPC server的处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sws *serverWatchStream)</span> <span class="title">sendLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// watch ids that are currently active</span></span><br><span class="line">   ids := <span class="built_in">make</span>(<span class="keyword">map</span>[mvcc.WatchID]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="comment">// watch responses pending on a watch id creation message</span></span><br><span class="line">   pending := <span class="built_in">make</span>(<span class="keyword">map</span>[mvcc.WatchID][]*pb.WatchResponse)</span><br><span class="line"></span><br><span class="line">   interval := GetProgressReportInterval()</span><br><span class="line">   progressTicker := time.NewTicker(interval)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 记录metrics数据，并做一些清理工作</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      progressTicker.Stop()</span><br><span class="line">      <span class="comment">// drain the chan to clean up pending events</span></span><br><span class="line">      <span class="keyword">for</span> ws := <span class="keyword">range</span> sws.watchStream.Chan() &#123;</span><br><span class="line">         mvcc.ReportEventReceived(<span class="built_in">len</span>(ws.Events))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> _, wrs := <span class="keyword">range</span> pending &#123;</span><br><span class="line">         <span class="keyword">for</span> _, ws := <span class="keyword">range</span> wrs &#123;</span><br><span class="line">            mvcc.ReportEventReceived(<span class="built_in">len</span>(ws.Events))</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// sendLoop监听两个channel</span></span><br><span class="line">   <span class="comment">// 1、创建/取消watch时的返回信息 ctrlStream</span></span><br><span class="line">   <span class="comment">// 2、新产生的事件 sws.watchStream.Chan()</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> wresp, ok := &lt;-sws.watchStream.Chan():</span><br><span class="line">         <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> evs is []mvccpb.Event type</span></span><br><span class="line">         <span class="comment">// either return []*mvccpb.Event from the mvcc package</span></span><br><span class="line">         <span class="comment">// or define protocol buffer with []mvccpb.Event.</span></span><br><span class="line">         evs := wresp.Events</span><br><span class="line">         events := <span class="built_in">make</span>([]*mvccpb.Event, <span class="built_in">len</span>(evs))</span><br><span class="line">         sws.mu.RLock()</span><br><span class="line">         needPrevKV := sws.prevKV[wresp.WatchID]</span><br><span class="line">         sws.mu.RUnlock()</span><br><span class="line">         <span class="keyword">for</span> i := <span class="keyword">range</span> evs &#123;</span><br><span class="line">            events[i] = &amp;evs[i]</span><br><span class="line">            <span class="keyword">if</span> needPrevKV &#123;</span><br><span class="line">               opt := mvcc.RangeOptions&#123;Rev: evs[i].Kv.ModRevision - <span class="number">1</span>&#125;</span><br><span class="line">               r, err := sws.watchable.Range(evs[i].Kv.Key, <span class="literal">nil</span>, opt)</span><br><span class="line">               <span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(r.KVs) != <span class="number">0</span> &#123;</span><br><span class="line">                  events[i].PrevKv = &amp;(r.KVs[<span class="number">0</span>])</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         canceled := wresp.CompactRevision != <span class="number">0</span></span><br><span class="line">         <span class="comment">//  带有event的watchResponse</span></span><br><span class="line">         wr := &amp;pb.WatchResponse&#123;</span><br><span class="line">            Header:          sws.newResponseHeader(wresp.Revision),</span><br><span class="line">            WatchId:         <span class="keyword">int64</span>(wresp.WatchID),</span><br><span class="line">            Events:          events,</span><br><span class="line">            CompactRevision: wresp.CompactRevision,</span><br><span class="line">            Canceled:        canceled,</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> _, okID := ids[wresp.WatchID]; !okID &#123;</span><br><span class="line">            <span class="comment">// buffer if id not yet announced</span></span><br><span class="line">            wrs := <span class="built_in">append</span>(pending[wresp.WatchID], wr)</span><br><span class="line">            pending[wresp.WatchID] = wrs</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         mvcc.ReportEventReceived(<span class="built_in">len</span>(evs))</span><br><span class="line"></span><br><span class="line">         sws.mu.RLock()</span><br><span class="line">         fragmented, ok := sws.fragment[wresp.WatchID]</span><br><span class="line">         sws.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> serr error</span><br><span class="line">         <span class="comment">// 判断是否需要分段发送</span></span><br><span class="line">         <span class="keyword">if</span> !fragmented &amp;&amp; !ok &#123;</span><br><span class="line">            serr = sws.gRPCStream.Send(wr)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serr = sendFragments(wr, sws.maxRequestBytes, sws.gRPCStream.Send)</span><br><span class="line">         &#125;</span><br><span class="line">        ...</span><br><span class="line">         sws.mu.Lock()</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(evs) &gt; <span class="number">0</span> &amp;&amp; sws.progress[wresp.WatchID] &#123;</span><br><span class="line">            <span class="comment">// elide next progress update if sent a key update</span></span><br><span class="line">            sws.progress[wresp.WatchID] = <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         sws.mu.Unlock()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样对于ctrlStream的处理大同小异，不在赘述。</p>
<h1 id="watchableStore处理"><a href="#watchableStore处理" class="headerlink" title="watchableStore处理"></a>watchableStore处理</h1><p>以上的处理流程分析仅限于gRPC层的client和server端数据交互，并未涉及真正的event数据的产生，那么event数据到底是怎么产生并且发送给上层gRPC端的呢？这就是本节<code>watchableStore</code>要做的事。</p>
<p>在创建新的watch请求一节的分析中我们知道，server端的watch请求调用了watchStream的wach方法，继续分析</p>
<p><code>watchStream</code>的wach方法可以发现它继续调用了watchable的watch方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w, c := ws.watchable.watch(key, end, startRev, id, ws.ch, fcs...)</span><br></pre></td></tr></table></figure>

<p>并且传入了一个ws.ch字段，而这个channel正是sendLoop中的接收事件的channel，因此可以发现watchableStore正是通过watchStream的这个channel将事件传送给gRPC server端。代码位置mvcc&#x2F;watcher.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *watchStream)</span> <span class="title">Chan</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">WatchResponse</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> ws.ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么watchableStore究竟是怎么处理的呢？进一步分析<code>watchableStore</code>的watch方法可以知道在处理每个watch请求时，会将每个watch请求放入到一个watchGroup的结构体中，watchGroup记录了watcher关注的key与watcher映射的集合，其中又分为关注单个key的watcher以及关注区间key的watcher，关注单个key的watcher直接放在map里存储，而关注区间的watcher则使用了区间树进行记录，以提高查找watcher的效率。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watcherGroup is a collection of watchers organized by their ranges</span></span><br><span class="line"><span class="keyword">type</span> watcherGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// 单个key对应的watcher</span></span><br><span class="line">   <span class="comment">// keyWatchers has the watchers that watch on a single key</span></span><br><span class="line">   keyWatchers watcherSetByKey</span><br><span class="line">   <span class="comment">// ranges has the watchers that watch a range; it is sorted by interval</span></span><br><span class="line">   <span class="comment">// 区间对应的watcher</span></span><br><span class="line">   ranges adt.IntervalTree</span><br><span class="line">   <span class="comment">// watchers is the set of all watchers</span></span><br><span class="line">   watchers watcherSet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且watch会根据watch请求的start revision进行分类，如果start revison比当前revision大或者从当前时刻开始监听，则把该请求放入sync集合，否则放入unsynced集合，为什么要这么分类呢？很显然如果从当前或者未来的某个revision版本号开始watch，则代表只有未来发生的事件才会被发送到相应watcher，也就是目前所有的事件都已同步，因此放到sync集合代表已同步，反之代表查询的是历史事件，由于历史事件需要查询bbolt数据，查询需要耗时因此放到unsynced集合代码数据还未同步，代码位置<code>mvcc/watchable_store.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *watchableStore)</span> <span class="title">watch</span><span class="params">(key, end []<span class="keyword">byte</span>, startRev <span class="keyword">int64</span>, id WatchID, ch <span class="keyword">chan</span>&lt;- WatchResponse, fcs ...FilterFunc)</span> <span class="params">(*watcher, cancelFunc)</span></span> &#123;</span><br><span class="line">   wa := &amp;watcher&#123;</span><br><span class="line">      key:    key,</span><br><span class="line">      end:    end,</span><br><span class="line">      minRev: startRev,</span><br><span class="line">      id:     id,</span><br><span class="line">      ch:     ch,</span><br><span class="line">      fcs:    fcs,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   s.revMu.RLock()</span><br><span class="line">   synced := startRev &gt; s.store.currentRev || startRev == <span class="number">0</span></span><br><span class="line">   <span class="comment">// 查询的不是是历史版本，直接放到synced watchGroup</span></span><br><span class="line">   <span class="keyword">if</span> synced &#123;</span><br><span class="line">      wa.minRev = s.store.currentRev + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> startRev &gt; wa.minRev &#123;</span><br><span class="line">         wa.minRev = startRev</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> synced &#123;</span><br><span class="line">      s.synced.add(wa)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 查询的是历史版本，需要到bbolt查找，放到unsynced watchGroup</span></span><br><span class="line">      slowWatcherGauge.Inc()</span><br><span class="line">      s.unsynced.add(wa)</span><br><span class="line">   &#125;</span><br><span class="line">   s.revMu.RUnlock()</span><br><span class="line">   s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   watcherGauge.Inc()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> wa, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; s.cancelWatcher(wa) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>watcherableStore</code>的watch方法仅仅将watcher添加到了sync或者unsynced结合，那么真正处理这些watcher的逻辑在哪里呢？</p>
<p><code>watcheableStore</code>在初始化的时候会有两个goroutine启动，分别是<code>syncWatchersLoop</code>和<code>syncVictimsLoop</code>，这是两个同步是事件到watcher的关键函数。而watchableStore的初始化时上层etcd server做的，在etcd server启动时就持久运行。syncWatchersLoop会持续处理unsynced集合里watcher，如果都已同步则等待100ms后进行下一次同步，而syncVictimsLoop则处理阻塞的暂时没发送到gRPC server端的事件。代码位置<code>mvcc/watchable_store.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWatchableStore</span><span class="params">(lg *zap.Logger, b backend.Backend, le lease.Lessor, as auth.AuthStore, ig ConsistentIndexGetter, cfg StoreConfig)</span> *<span class="title">watchableStore</span></span> &#123;</span><br><span class="line">   s := &amp;watchableStore&#123;</span><br><span class="line">      store:    NewStore(lg, b, le, ig, cfg),</span><br><span class="line">      victimc:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">      unsynced: newWatcherGroup(),</span><br><span class="line">      synced:   newWatcherGroup(),</span><br><span class="line">      stopc:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">   &#125;</span><br><span class="line">   s.store.ReadView = &amp;readView&#123;s&#125;</span><br><span class="line">   s.store.WriteView = &amp;writeView&#123;s&#125;</span><br><span class="line">   <span class="keyword">if</span> s.le != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// use this store as the deleter so revokes trigger watch events</span></span><br><span class="line">      s.le.SetRangeDeleter(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">lease</span>.<span class="title">TxnDelete</span></span> &#123; <span class="keyword">return</span> s.Write(traceutil.TODO()) &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> as != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> encapsulating consistentindex into a separate package</span></span><br><span class="line">      as.SetConsistentIndexSyncer(s.store.saveIndex)</span><br><span class="line">   &#125;</span><br><span class="line">   s.wg.Add(<span class="number">2</span>)</span><br><span class="line">   <span class="comment">// 每100ms处理unsynced的请求</span></span><br><span class="line">   <span class="keyword">go</span> s.syncWatchersLoop()</span><br><span class="line">   <span class="comment">// 处理victim也就是阻塞的事件</span></span><br><span class="line">   <span class="keyword">go</span> s.syncVictimsLoop()</span><br><span class="line">   <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="syncWatchersLoop"><a href="#syncWatchersLoop" class="headerlink" title="syncWatchersLoop"></a>syncWatchersLoop</h2><p>syncWatchersLoop调用syncWatchers方法进行同步，分四个步骤进行</p>
<ol>
<li>从unsynced集合中选取一部分watchers集合</li>
<li>遍历集合选出最小的revision并且移除掉revision已经被压缩的watcher</li>
<li>使用最小的revision获得所有所有kv pair发送给相应的wacher</li>
<li>当unsynced集合里的watcher事件都发送完毕后将watcher移出unsynced，放入sync集合</li>
</ol>
<p>代码位置<code>mvcc/watchable_store.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *watchableStore)</span> <span class="title">syncWatchers</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> s.unsynced.size() == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   s.store.revMu.RLock()</span><br><span class="line">   <span class="keyword">defer</span> s.store.revMu.RUnlock()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// in order to find key-value pairs from unsynced watchers, we need to</span></span><br><span class="line">   <span class="comment">// find min revision index, and these revisions can be used to</span></span><br><span class="line">   <span class="comment">// query the backend store of key-value pairs</span></span><br><span class="line">   curRev := s.store.currentRev</span><br><span class="line">   compactionRev := s.store.compactMainRev</span><br><span class="line"></span><br><span class="line">   <span class="comment">// step1、step2</span></span><br><span class="line">   wg, minRev := s.unsynced.choose(maxWatchersPerSync, curRev, compactionRev)</span><br><span class="line">   minBytes, maxBytes := newRevBytes(), newRevBytes()</span><br><span class="line">   revToBytes(revision&#123;main: minRev&#125;, minBytes)</span><br><span class="line">   revToBytes(revision&#123;main: curRev + <span class="number">1</span>&#125;, maxBytes)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// UnsafeRange returns keys and values. And in boltdb, keys are revisions.</span></span><br><span class="line">   <span class="comment">// values are actual key-value pairs in backend.</span></span><br><span class="line">   tx := s.store.b.ReadTx()</span><br><span class="line">   tx.RLock()</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// step3</span></span><br><span class="line">   revs, vs := tx.UnsafeRange(keyBucketName, minBytes, maxBytes, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">var</span> evs []mvccpb.Event</span><br><span class="line">   <span class="keyword">if</span> s.store != <span class="literal">nil</span> &amp;&amp; s.store.lg != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 对key进行转换并过滤掉没有被watch的key</span></span><br><span class="line">      evs = kvsToEvents(s.store.lg, wg, revs, vs)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> remove this in v3.5</span></span><br><span class="line">      evs = kvsToEvents(<span class="literal">nil</span>, wg, revs, vs)</span><br><span class="line">   &#125;</span><br><span class="line">   tx.RUnlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> victims watcherBatch</span><br><span class="line">   <span class="comment">// 产生watcher和其对应的eventBatch</span></span><br><span class="line">   wb := newWatcherBatch(wg, evs)</span><br><span class="line">   <span class="keyword">for</span> w := <span class="keyword">range</span> wg.watchers &#123;</span><br><span class="line">      <span class="comment">// 重新设置nimRev防止重复接收事件</span></span><br><span class="line">      w.minRev = curRev + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">      eb, ok := wb[w]</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         <span class="comment">// bring un-notified watcher to synced</span></span><br><span class="line">         s.synced.add(w)</span><br><span class="line">         s.unsynced.<span class="built_in">delete</span>(w)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> eb.moreRev != <span class="number">0</span> &#123;</span><br><span class="line">         w.minRev = eb.moreRev</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// step3</span></span><br><span class="line">      <span class="keyword">if</span> w.send(WatchResponse&#123;WatchID: w.id, Events: eb.evs, Revision: curRev&#125;) &#123;</span><br><span class="line">         pendingEventsGauge.Add(<span class="keyword">float64</span>(<span class="built_in">len</span>(eb.evs)))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果发送到chan时阻塞，说明有block，此时把watcher和对应的event batch加入到victims</span></span><br><span class="line">         <span class="keyword">if</span> victims == <span class="literal">nil</span> &#123;</span><br><span class="line">            victims = <span class="built_in">make</span>(watcherBatch)</span><br><span class="line">         &#125;</span><br><span class="line">         w.victim = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> w.victim &#123;</span><br><span class="line">         victims[w] = eb</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> eb.moreRev != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// stay unsynced; more to read</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// step4</span></span><br><span class="line">         <span class="comment">// 添加到已同步集合</span></span><br><span class="line">         s.synced.add(w)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从未同步集合移除</span></span><br><span class="line">      s.unsynced.<span class="built_in">delete</span>(w)</span><br><span class="line">   &#125;</span><br><span class="line">   s.addVictim(victims)</span><br><span class="line"></span><br><span class="line">   vsz := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> s.victims &#123;</span><br><span class="line">      vsz += <span class="built_in">len</span>(v)</span><br><span class="line">   &#125;</span><br><span class="line">   slowWatcherGauge.Set(<span class="keyword">float64</span>(s.unsynced.size() + vsz))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> s.unsynced.size()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注一下其中的<code>newWatcherBatch</code>函数，该函数传入watcherGroup和所有从bbolt查询的事件，然后根每个key的ModRevision与每个watcher关注的minRev进行比较，ModRevision大于minRev意味着key有了更新事件，因此会该事件会添加到对应watcher的eventBatch集合里。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回watcher和对应的event</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWatcherBatch</span><span class="params">(wg *watcherGroup, evs []mvccpb.Event)</span> <span class="title">watcherBatch</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(wg.watchers) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   wb := <span class="built_in">make</span>(watcherBatch)</span><br><span class="line">   <span class="comment">// 遍历所有的Event，根据Event的key来查找指定的watcher</span></span><br><span class="line">   <span class="keyword">for</span> _, ev := <span class="keyword">range</span> evs &#123;</span><br><span class="line">      <span class="keyword">for</span> w := <span class="keyword">range</span> wg.watcherSetByKey(<span class="keyword">string</span>(ev.Kv.Key)) &#123;</span><br><span class="line">         <span class="comment">// 说明指定的key发生了变化</span></span><br><span class="line">         <span class="keyword">if</span> ev.Kv.ModRevision &gt;= w.minRev &#123;</span><br><span class="line">            <span class="comment">// don&#x27;t double notify</span></span><br><span class="line">            wb.add(w, ev)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> wb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="syncVictimsLoop"><a href="#syncVictimsLoop" class="headerlink" title="syncVictimsLoop"></a>syncVictimsLoop</h2><p>由于send事件用的channel没有缓存，因此如果在发生阻塞时会创建victim集合记录阻塞的watcher和对应的eventBatch，然后由<code>syncVictimsLoop</code>协程进行单独处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *watchableStore)</span> <span class="title">syncVictimsLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> s.wg.Done()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// 不等于0说明一直有pending的event可以发送，所以一直发送</span></span><br><span class="line">      <span class="comment">// 直到所有的event全部阻塞</span></span><br><span class="line">      <span class="keyword">for</span> s.moveVictims() != <span class="number">0</span> &#123;</span><br><span class="line">         <span class="comment">// try to update all victim watchers</span></span><br><span class="line">      &#125;</span><br><span class="line">      s.mu.RLock()</span><br><span class="line">      isEmpty := <span class="built_in">len</span>(s.victims) == <span class="number">0</span></span><br><span class="line">      s.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> tickc &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">      <span class="keyword">if</span> !isEmpty &#123;</span><br><span class="line">         <span class="comment">// victims不为空10ms处理一次</span></span><br><span class="line">         tickc = time.After(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-tickc:</span><br><span class="line">         <span class="comment">// 阻塞到这里等待有victims产生</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-s.victimc:</span><br><span class="line">      <span class="keyword">case</span> &lt;-s.stopc:</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数会持续调用<code>moveVictims</code>尝发送victims阻塞的watcher，直到阻塞的watcher事件全部发送完毕。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// moveVictims tries to update watches with already pending event data</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *watchableStore)</span> <span class="title">moveVictims</span><span class="params">()</span> <span class="params">(moved <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   victims := s.victims</span><br><span class="line">   s.victims = <span class="literal">nil</span></span><br><span class="line">   s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> newVictim watcherBatch</span><br><span class="line">   <span class="keyword">for</span> _, wb := <span class="keyword">range</span> victims &#123;</span><br><span class="line">      <span class="comment">// try to send responses again</span></span><br><span class="line">      <span class="comment">// 尝试继续发送阻塞的事件</span></span><br><span class="line">      <span class="keyword">for</span> w, eb := <span class="keyword">range</span> wb &#123;</span><br><span class="line">         <span class="comment">// watcher has observed the store up to, but not including, w.minRev</span></span><br><span class="line">         rev := w.minRev - <span class="number">1</span></span><br><span class="line">         <span class="keyword">if</span> w.send(WatchResponse&#123;WatchID: w.id, Events: eb.evs, Revision: rev&#125;) &#123;</span><br><span class="line">            pendingEventsGauge.Add(<span class="keyword">float64</span>(<span class="built_in">len</span>(eb.evs)))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> newVictim == <span class="literal">nil</span> &#123;</span><br><span class="line">               newVictim = <span class="built_in">make</span>(watcherBatch)</span><br><span class="line">            &#125;</span><br><span class="line">            newVictim[w] = eb</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         moved++</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// assign completed victim watchers to unsync/sync</span></span><br><span class="line">      s.mu.Lock()</span><br><span class="line">      s.store.revMu.RLock()</span><br><span class="line">      curRev := s.store.currentRev</span><br><span class="line">      <span class="keyword">for</span> w, eb := <span class="keyword">range</span> wb &#123;</span><br><span class="line">         <span class="keyword">if</span> newVictim != <span class="literal">nil</span> &amp;&amp; newVictim[w] != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// couldn&#x27;t send watch response; stays victim</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         w.victim = <span class="literal">false</span></span><br><span class="line">         <span class="keyword">if</span> eb.moreRev != <span class="number">0</span> &#123;</span><br><span class="line">            w.minRev = eb.moreRev</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 存在未同步的事件，放入unsynced，然后由syncWatcherLoop处理</span></span><br><span class="line">         <span class="keyword">if</span> w.minRev &lt;= curRev &#123;</span><br><span class="line">            s.unsynced.add(w)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slowWatcherGauge.Dec()</span><br><span class="line">            s.synced.add(w)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      s.store.revMu.RUnlock()</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(newVictim) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      s.mu.Lock()</span><br><span class="line">      s.victims = <span class="built_in">append</span>(s.victims, newVictim)</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> moved</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="新事件来源"><a href="#新事件来源" class="headerlink" title="新事件来源"></a>新事件来源</h2><p>以上同步的watcher都是从unsynced集合中取的，也就是说事件来源都是历史事件，那么新来的事件的也就是sync集合里关注的新事件什么时候会被发送呢？这就是前面提到的<code>watcherableStore</code>的回调函数，该函数会在每次进行key更新或删除时进行调用，通知有新的事件发生，然后发送到gRPC server上层。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// notify notifies the fact that given event at the given rev just happened to</span></span><br><span class="line"><span class="comment">// watchers that watch on the key of the event.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *watchableStore)</span> <span class="title">notify</span><span class="params">(rev <span class="keyword">int64</span>, evs []mvccpb.Event)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> victim watcherBatch</span><br><span class="line">   <span class="comment">// 选出watcher关注得到事件</span></span><br><span class="line">   <span class="keyword">for</span> w, eb := <span class="keyword">range</span> newWatcherBatch(&amp;s.synced, evs) &#123;</span><br><span class="line">      <span class="keyword">if</span> eb.revs != <span class="number">1</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> s.store != <span class="literal">nil</span> &amp;&amp; s.store.lg != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.store.lg.Panic(</span><br><span class="line">               <span class="string">&quot;unexpected multiple revisions in watch notification&quot;</span>,</span><br><span class="line">               zap.Int(<span class="string">&quot;number-of-revisions&quot;</span>, eb.revs),</span><br><span class="line">            )</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            plog.Panicf(<span class="string">&quot;unexpected multiple revisions in notification&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 发送到上层</span></span><br><span class="line">      <span class="keyword">if</span> w.send(WatchResponse&#123;WatchID: w.id, Events: eb.evs, Revision: rev&#125;) &#123;</span><br><span class="line">         pendingEventsGauge.Add(<span class="keyword">float64</span>(<span class="built_in">len</span>(eb.evs)))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// move slow watcher to victims</span></span><br><span class="line">         w.minRev = rev + <span class="number">1</span></span><br><span class="line">         <span class="keyword">if</span> victim == <span class="literal">nil</span> &#123;</span><br><span class="line">            victim = <span class="built_in">make</span>(watcherBatch)</span><br><span class="line">         &#125;</span><br><span class="line">         w.victim = <span class="literal">true</span></span><br><span class="line">         victim[w] = eb</span><br><span class="line">         s.synced.<span class="built_in">delete</span>(w)</span><br><span class="line">         slowWatcherGauge.Inc()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果有阻塞的watch事件，放到victim</span></span><br><span class="line">   s.addVictim(victim)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回调函数<code>notify</code>会在每次key的事务结束时进行调用，通知新事件的产生。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *watchableStoreTxnWrite)</span> <span class="title">End</span><span class="params">()</span></span> &#123;</span><br><span class="line">   changes := tw.Changes()</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(changes) == <span class="number">0</span> &#123;</span><br><span class="line">      tw.TxnWrite.End()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   rev := tw.Rev() + <span class="number">1</span></span><br><span class="line">   evs := <span class="built_in">make</span>([]mvccpb.Event, <span class="built_in">len</span>(changes))</span><br><span class="line">   <span class="keyword">for</span> i, change := <span class="keyword">range</span> changes &#123;</span><br><span class="line">      evs[i].Kv = &amp;changes[i]</span><br><span class="line">      <span class="keyword">if</span> change.CreateRevision == <span class="number">0</span> &#123;</span><br><span class="line">         evs[i].Type = mvccpb.DELETE</span><br><span class="line">         evs[i].Kv.ModRevision = rev</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         evs[i].Type = mvccpb.PUT</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// end write txn under watchable store lock so the updates are visible</span></span><br><span class="line">   <span class="comment">// when asynchronous event posting checks the current store revision</span></span><br><span class="line">   tw.s.mu.Lock()</span><br><span class="line">   <span class="comment">// 通知watch有新的事件产生</span></span><br><span class="line">   tw.s.notify(rev, evs)</span><br><span class="line">   tw.TxnWrite.End()</span><br><span class="line">   tw.s.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>etcd的watch分层设计合理，各个模块各司其职，通过channel进行模块间的通信，简化了设计也提升了并发处理能力，并且区分了历史事件和实时事件进行不同处理，逻辑变得更加清晰，通过对watch机制源码层面的剖析不仅可以加深对watch机制的理解，同时也可以学习优秀的代码设计。</p>
]]></content>
      <tags>
        <tag>源码</tag>
        <tag>Etcd</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go HTTP Server源码分析</title>
    <url>/2022/03/30/go-http/</url>
    <content><![CDATA[<h1 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h1><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>共有两种启动方式</p>
<ul>
<li><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;io&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    _, _ = io.WriteString(w, <span class="string">&quot;hello, world!\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注册路由</span></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">    <span class="comment">// 创建监听服务</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloHandlerStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    str <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *HelloHandlerStruct)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, handler.str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">&quot;/&quot;</span>, &amp;HelloHandlerStruct&#123;str: <span class="string">&quot;Hello World&quot;</span>&#125;)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>第一种方式通过调用<code>http.HandleFunc</code>函数来进行路由注册，绑定路由和handler，其中函数的第二个参数为<code>func(ResponseWriter, *Request)</code>类型的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式通过调用<code>http.Handle</code>进行绑定，函数第二个参数为一个<code>Handler</code>类型的<code>interface</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123; DefaultServeMux.Handle(pattern, handler) &#125;</span><br></pre></td></tr></table></figure>

<p><code>Handler</code>定义如下，因此只要传入一个实现了<code>ServeHTTP</code>方法的<code>strut</code>即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式的共同点在于路由注册函数内部调用的都是<code>DefaultServeMux</code>这个处理HTTP请求的多路复用器进行路由注册，这是一个go默认的<code>HTTP ServeMux</code>，结构如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">    es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">    hosts <span class="keyword">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也正是因为<code>http</code>包提供了默认的的<code>ServeMux</code>负责处理路由绑定，所以上述两种方式最后调用的<code>http.ListenAndServe</code>函数的第二个参数为<code>nil</code>，即不指定时用的就是默认的<code>DefaultServeMux</code>，当然也可以手动显式声明一个<code>ServeMux</code>类型的变量。</p>
<p>进一步分析可以发现第一种方式虽然传递的是一个<code>func</code>，但会对这个<code>func</code>进行进一步的处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;http: nil handler&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用真正的mux进行处理</span></span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>mux.Handle</code>的第二个参数<code>handler</code>转换成了<code>HandlerFunc</code>，而由于<code>HandlerFunc</code>实现了<code>ServeHTTP</code>接口，故而已经变成了一个可以处理请求的<code>Handler</code>，所以两种方式是殊途同归的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h1><p>从demo的<code>HandleFunc/Handle</code>函数入口，分析路由注册过程，从以上分析可以看出，路由注册主要通过<code>ServeMux</code>进行，server端对外暴露的<code>HandleFunc/Handle</code>函数主要的处理逻辑都是最终通过<code>ServeMux</code>这个<code>strut</code>来实现的，接下来深入分析<code>ServeMux</code>的工作逻辑</p>
<h2 id="Handler函数"><a href="#Handler函数" class="headerlink" title="Handler函数"></a>Handler函数</h2><p>注册路由时最终调用的就是<code>ServeMux.Handle</code>函数，代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 三层校验，pattern、handle不能为空且不能重复注册pattern</span></span><br><span class="line">    <span class="keyword">if</span> pattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;http: invalid pattern&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;http: nil handler&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;http: multiple registrations for &quot;</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将handler和pattern封装成muxEntry</span></span><br><span class="line">    e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">    <span class="comment">// 将pattern和muxEntry的映射存入mux.m字段，方便后续快速通过pattern查找对应的handler</span></span><br><span class="line">    mux.m[pattern] = e</span><br><span class="line">    <span class="comment">// 通过appendSorted函数将所有pattern按照长度从大到小排序，为的是按序依次从长到端短匹配路由</span></span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">        mux.es = appendSorted(mux.es, e)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">        mux.hosts = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的主要逻辑就是先进行一些必要的前置条件检查，然后将外部传入的handler和pattern封装在自己的私有字段中，方便后续根据pattern查找对应的handler进行快速处理</p>
<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>路由注册完成调用<code>http.ListenAndServe</code>方法启动一个http server，该方法主要启动一个<code>Server</code>实例然后调用<code>server.ListenAndServe()</code>监听指定端口的TCP连接并进行处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p><code>Server</code>定义了包含HTTP服务running的参数，包括了地址、Handler、tls等基本信息，超时时间，头部限制自己数，keepalive和shutdown处理函数等参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 监听的TCP连接地址，默认为80端口</span></span><br><span class="line">    Addr <span class="keyword">string</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认为http.DefaultServeMux</span></span><br><span class="line">    Handler Handler </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TLS配置</span></span><br><span class="line">    TLSConfig *tls.Config</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一些读写操作的超时时间</span></span><br><span class="line">    ReadTimeout time.Duration</span><br><span class="line">    </span><br><span class="line">    ReadHeaderTimeout time.Duration</span><br><span class="line">    </span><br><span class="line">    WriteTimeout time.Duration</span><br><span class="line">    </span><br><span class="line">    IdleTimeout time.Duration</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MaxHeaderBytes controls the maximum number of bytes the</span></span><br><span class="line">    <span class="comment">// server will read parsing the request header&#x27;s keys and</span></span><br><span class="line">    <span class="comment">// values, including the request line. It does not limit the</span></span><br><span class="line">    <span class="comment">// size of the request body.</span></span><br><span class="line">    <span class="comment">// If zero, DefaultMaxHeaderBytes is used.</span></span><br><span class="line">    MaxHeaderBytes <span class="keyword">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TLSNextProto optionally specifies a function to take over</span></span><br><span class="line">    <span class="comment">// ownership of the provided TLS connection when an ALPN</span></span><br><span class="line">    <span class="comment">// protocol upgrade has occurred. The map key is the protocol</span></span><br><span class="line">    <span class="comment">// name negotiated. The Handler argument should be used to</span></span><br><span class="line">    <span class="comment">// handle HTTP requests and will initialize the Request&#x27;s TLS</span></span><br><span class="line">    <span class="comment">// and RemoteAddr if not already set. The connection is</span></span><br><span class="line">    <span class="comment">// automatically closed when the function returns.</span></span><br><span class="line">    <span class="comment">// If TLSNextProto is not nil, HTTP/2 support is not enabled</span></span><br><span class="line">    <span class="comment">// automatically.</span></span><br><span class="line">    TLSNextProto <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*Server, *tls.Conn, Handler)</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ConnState specifies an optional callback function that is</span></span><br><span class="line">    <span class="comment">// called when a client connection changes state. See the</span></span><br><span class="line">    <span class="comment">// ConnState type and associated constants for details.</span></span><br><span class="line">    ConnState <span class="function"><span class="keyword">func</span><span class="params">(net.Conn, ConnState)</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ErrorLog specifies an optional logger for errors accepting</span></span><br><span class="line">    <span class="comment">// connections, unexpected behavior from handlers, and</span></span><br><span class="line">    <span class="comment">// underlying FileSystem errors.</span></span><br><span class="line">    <span class="comment">// If nil, logging is done via the log package&#x27;s standard logger.</span></span><br><span class="line">    ErrorLog *log.Logger</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BaseContext optionally specifies a function that returns</span></span><br><span class="line">    <span class="comment">// the base context for incoming requests on this server.</span></span><br><span class="line">    <span class="comment">// The provided Listener is the specific Listener that&#x27;s</span></span><br><span class="line">    <span class="comment">// about to start accepting requests.</span></span><br><span class="line">    <span class="comment">// If BaseContext is nil, the default is context.Background().</span></span><br><span class="line">    <span class="comment">// If non-nil, it must return a non-nil context.</span></span><br><span class="line">    BaseContext <span class="function"><span class="keyword">func</span><span class="params">(net.Listener)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ConnContext optionally specifies a function that modifies</span></span><br><span class="line">    <span class="comment">// the context used for a new connection c. The provided ctx</span></span><br><span class="line">    <span class="comment">// is derived from the base context and has a ServerContextKey</span></span><br><span class="line">    <span class="comment">// value.</span></span><br><span class="line">    ConnContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, c net.Conn)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line">    </span><br><span class="line">    inShutdown atomicBool <span class="comment">// true when when server is in shutdown</span></span><br><span class="line">    </span><br><span class="line">    disableKeepAlives <span class="keyword">int32</span>     <span class="comment">// accessed atomically.</span></span><br><span class="line">    nextProtoOnce     sync.Once <span class="comment">// guards setupHTTP2_* init</span></span><br><span class="line">    nextProtoErr      error     <span class="comment">// result of http2.ConfigureServer if used</span></span><br><span class="line">    </span><br><span class="line">    mu         sync.Mutex</span><br><span class="line">    listeners  <span class="keyword">map</span>[*net.Listener]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    activeConn <span class="keyword">map</span>[*conn]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    doneChan   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    onShutdown []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ListenAndServe函数"><a href="#ListenAndServe函数" class="headerlink" title="ListenAndServe函数"></a>ListenAndServe函数</h2><p>然后分析<code>Server</code>的<code>ListenAndServe</code>函数，主要逻辑就是调用socket的接口进行监听然后接收连接，socket相关源码可另行查阅，本文只关注go的http层的相关逻辑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断服务是否正在关闭</span></span><br><span class="line">    <span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填充默认值</span></span><br><span class="line">    addr := srv.Addr</span><br><span class="line">    <span class="keyword">if</span> addr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        addr = <span class="string">&quot;:http&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用socket函数就行监听</span></span><br><span class="line">    ln, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动server接收连接</span></span><br><span class="line">    <span class="keyword">return</span> srv.Serve(ln)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>srv.Serve</code>的主要流程就是接收新的连接然后对每一个连接启动新的goroutine进行处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Serve accepts incoming connections on the Listener l, creating a</span></span><br><span class="line"><span class="comment">// new service goroutine for each. The service goroutines read requests and</span></span><br><span class="line"><span class="comment">// then call srv.Handler to reply to them.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// HTTP/2 support is only enabled if the Listener returns *tls.Conn</span></span><br><span class="line"><span class="comment">// connections and they were configured with &quot;h2&quot; in the TLS</span></span><br><span class="line"><span class="comment">// Config.NextProtos.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Serve always returns a non-nil error and closes l.</span></span><br><span class="line"><span class="comment">// After Shutdown or Close, the returned error is ErrServerClosed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">    	fn(srv, l) <span class="comment">// call hook with unwrapped listener</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    origListener := l</span><br><span class="line">    l = &amp;onceCloseListener&#123;Listener: l&#125;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置http2 server</span></span><br><span class="line">    <span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> !srv.trackListener(&amp;l, <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> srv.trackListener(&amp;l, <span class="literal">false</span>)</span><br><span class="line">    </span><br><span class="line">    baseCtx := context.Background()</span><br><span class="line">    <span class="keyword">if</span> srv.BaseContext != <span class="literal">nil</span> &#123;</span><br><span class="line">        baseCtx = srv.BaseContext(origListener)</span><br><span class="line">        <span class="keyword">if</span> baseCtx == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;BaseContext returned a nil context&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据接收到的listerner设置相关context</span></span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 等待新的连接</span></span><br><span class="line">        rw, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">                <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                srv.logf(<span class="string">&quot;http: Accept error: %v; retrying in %v&quot;</span>, err, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        connCtx := ctx</span><br><span class="line">        <span class="keyword">if</span> cc := srv.ConnContext; cc != <span class="literal">nil</span> &#123;</span><br><span class="line">            connCtx = cc(connCtx, rw)</span><br><span class="line">            <span class="keyword">if</span> connCtx == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;ConnContext returned nil&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        c.setState(c.rwc, StateNew, runHooks) <span class="comment">// before Serve can return</span></span><br><span class="line">        <span class="comment">// 启动goroutine处理每一个新的连接</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(connCtx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后走到<code>c.serve</code>函数，函数较长，这里只保留主要逻辑，最主要的步骤就是调用<code>serverHandler.ServeHTTP</code>进行处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 保存response</span></span><br><span class="line">    c.curReq.Store(w)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> requestBodyRemains(req.Body) &#123;</span><br><span class="line">        registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        w.conn.r.startBackgroundRead()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传入response w参数，上层handler处理完写到w，然后后续将w返回给请求方</span></span><br><span class="line">    serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">    w.cancelCtx()</span><br><span class="line">    <span class="keyword">if</span> c.hijacked() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    w.finishRequest()</span><br><span class="line">    <span class="keyword">if</span> !w.shouldReuseConnection() &#123;</span><br><span class="line">        <span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line">            c.closeWriteAndWait()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.setState(c.rwc, StateIdle, runHooks)</span><br><span class="line">    c.curReq.Store((*response)(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>serverHandler</code>是一个上层handle的委托，同样实现了<code>ServeHTTP</code>方法然后通过上层传递的Handler直接调用<code>ServeHTTP</code>进行处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="comment">// 若传递Handler为空，则使用默认的DefaultServeMux</span></span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">    	handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.RequestURI == <span class="string">&quot;*&quot;</span> &amp;&amp; req.Method == <span class="string">&quot;OPTIONS&quot;</span> &#123;</span><br><span class="line">        handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里也再次印证了上文demo里说的<code>http.ListenAndServe</code>函数若第二个参数为<code>nil</code>，则使用默认的Handle进行处理。因此接着分析<code>DefaultServeMux</code>的<code>ServeHTTP</code>方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">&quot;*&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">            w.Header().Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        w.WriteHeader(StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找每个request对应的handler</span></span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    <span class="comment">// 调用上层事先定义的每个路由对应的具体hander进行处理</span></span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里逻辑就已经十分清晰了，通过<code>mux.Handler</code>函数查找事先定义的hander，然后直接调用hander的<code>ServeHTTP</code>方法处理即可，然后在看下具体是怎么通过请求参数查找对应handler的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// CONNECT requests are not canonicalized.</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">&quot;CONNECT&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// If r.URL.Path is /tree and its handler is not registered,</span></span><br><span class="line">        <span class="comment">// the /tree -&gt; /tree/ redirect applies to CONNECT requests</span></span><br><span class="line">        <span class="comment">// but the path canonicalization does not.</span></span><br><span class="line">        <span class="keyword">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// host、path数据清理 </span></span><br><span class="line">    <span class="comment">//只提取主机名</span></span><br><span class="line">    host := stripHostPort(r.Host)</span><br><span class="line">    <span class="comment">// 得到真实的path，如/hello/world/../会被转化为/hello/world</span></span><br><span class="line">    path := cleanPath(r.URL.Path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If the given path is /tree and its handler is not registered,</span></span><br><span class="line">    <span class="comment">// redirect for /tree/.</span></span><br><span class="line">    <span class="keyword">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重定向操作</span></span><br><span class="line">    <span class="keyword">if</span> path != r.URL.Path &#123;</span><br><span class="line">        _, pattern = mux.handler(host, path)</span><br><span class="line">        url := *r.URL</span><br><span class="line">        url.Path = path</span><br><span class="line">        <span class="keyword">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继续查找得到真正的handler</span></span><br><span class="line">    <span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续调用<code>mux.handler</code>进行进一步的处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    mux.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先查找是否为特定主机的path</span></span><br><span class="line">    <span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">        h, pattern = mux.match(host + path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h, pattern = mux.match(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有对应的handler，返回404</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h, pattern = NotFoundHandler(), <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过match函数查找pattern对应的路由，若没有对应的路由，返回404</p>
<p>match函数的实现就比较简单了，首先直接进行映射查找，若找到直接返回，否则进行最长匹配查找，直到找到根路劲<code>/</code>为止</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">match</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Check for exact match first.</span></span><br><span class="line">    v, ok := mux.m[path]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check for longest valid match.  mux.es contains all patterns</span></span><br><span class="line">    <span class="comment">// that end in / sorted from longest to shortest.</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> mux.es &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.HasPrefix(path, e.pattern) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.h, e.pattern</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优雅关停"><a href="#优雅关停" class="headerlink" title="优雅关停"></a>优雅关停</h1><p>生产环境中，通常会在<code>http</code>服务关闭时处理一些收尾工作，防止对进行到一半的连接实施暴力停止时发生一些意想不到的后果，此时就可以借助http的<code>Shutdown</code>函数和go的<code>channel</code>进行优雅关停</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">  <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.Handle(<span class="string">&quot;/&quot;</span>, &amp;helloHandler&#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    server := &amp;http.Server&#123;</span><br><span class="line">      Addr:    <span class="string">&quot;:8081&quot;</span>,</span><br><span class="line">      Handler: mux,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建系统信号接收器</span></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      &lt;-done</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> err := server.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatal(<span class="string">&quot;Shutdown server:&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    log.Println(<span class="string">&quot;Starting HTTP server...&quot;</span>)</span><br><span class="line">    err := server.ListenAndServe()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> err == http.ErrServerClosed &#123;</span><br><span class="line">         log.Print(<span class="string">&quot;Server closed under request&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         log.Fatal(<span class="string">&quot;Server closed unexpected&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> helloHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*helloHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自定义的<code>Server</code>对象作为<code>sever</code>端进行处理，主协程启动监听处理连接，然后定义系统信号(Ctrl+c或者<code>SIGTERM</code>等)，通过<code>channel</code>监听信号变化，收到信号后可以做一些收尾工作，然后调用<code>server.Shutdown</code>函数通知主协程停止服务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>go</code>的<code>http</code>包暴露了两个函数<code>http.Handle/HandleFunc</code>和<code>ListenAndServe</code>，通过这两个函数我们可以快速的搭建起一个http服务，简单易用，内部逻辑对使用者透明。本文从这两个函数入手，分析了其内部实现，即外部通<code>Handler/HandlerFunc</code>绑定路由和<code>hander</code>，而这些路由和hander都会被封到<code>ServeMux</code>这个<code>strut</code>中，然后通过一个<code>http.Server</code>绑定<code>ServeMux</code>这个<code>Handler</code>，并通过调用<code>socket</code>相关接口实现底层通信，进一步对外透明，体现出分层设计和低耦合的设计思想。最终会根据每个请求的路径<code>pattern</code>选择合适的<code>hander</code>处理，上层处理完，<code>socket</code>直接取结果即可，这其中也涉及用户态与内核态的切换工作。最后使用了优雅关停来处理服务器关闭前的收尾工作。本文分析着重于应用层，相关的socket原理以及高性能服务器实现的多路复用等技术并未涉及，留待以后探讨。</p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
</search>
